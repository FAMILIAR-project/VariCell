<!--?xml version="1.0" encoding="UTF-8" ?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <title>Comparison of programming languages (mapping)</title> 
  <style type="text/css">
		<!--
			/**
			 * Copyright 2011 The Open Source Research Group,
			 *                University of Erlangen-N??rnberg
			 *
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */
			
			/******************************************************************************* 
			 * Default CSS styles for HtmlPrinters
			 ******************************************************************************/
			h1,h2,h3,h4,h5,h6 {
				background: none repeat scroll 0 0 transparent;
				border-bottom: 1px solid #AAAAAA;
				color: black;
				font-weight: normal;
				margin: 0;
				padding-bottom: 0.17em;
				width: auto;
				text-align: left;
			}
			
			h1,h2 {
				margin-bottom: 0.6em;
			}
			
			h3,h4,h5,h6 {
				border-bottom: medium none;
				font-weight: bold;
			}
			
			h3,h4,h5 {
				margin-bottom: 0.3em;
			}
			
			h1 {
				font-size: 188%;
			}
			
			h2 {
				font-size: 150%;
			}
			
			h3 {
				font-size: 132%;
			}
			
			p {
				line-height: 1.5em;
				margin: 0.4em 0 0.5em;
				/* DEBUG: */
				border: 1px solid silver;
				margin: 1px;
			}
			
			pre {
				padding: 1em;
				border: 1px dashed #2F6FAB;
				color: black;
				background-color: #F9F9F9;
				line-height: 1.1em;
				font-family: monospace, "Courier New";
			}
			
			.content {
				line-height: 1.5em;
				color: black;
				font-family: sans-serif;
			}
			
			.article-heading {
				font-size: 1.6em;
				line-height: 1.2em;
				margin-bottom: 0.1em;
				margin-top: 0;
				padding-bottom: 0;
				padding-top: 0;
			}
			
			.article-content {
				line-height: 1.5em;
				position: relative;
				width: 100%;
				font-size: 0.8em;
			}
			
			.section {
				padding-top: 0.5em;
				/* DEBUG: */
				border-left: 2px solid #FF6633;
				padding-top: 0;
				padding-left: 1em;
				margin-top: 1em;
				margin-bottom: 1em;
			}
			
			/******************************************************************************* 
			 * Images 
			 ******************************************************************************/
			div.thumb {
				background-color: transparent;
				border-color: white;
				border-style: solid;
				margin-bottom: 0.5em;
				max-width: 234px;
			}
			
			div.thumbinner {
				background-color: #F9F9F9;
				border: 1px solid #CCCCCC;
				font-size: 94%;
				overflow: hidden;
				padding: 3px !important;
				text-align: center;
			}
			
			img.thumbimage {
				border: 1px solid #CCCCCC;
				max-width: 220px;
				max-height: 225px;
			}
			
			img.plainimage {
				max-width: 220px;
				max-height: 225px;
			}
			
			div.thumbcaption {
				border: medium none;
				font-size: 94%;
				line-height: 1.4em;
				padding: 3px !important;
				text-align: left;
			}
			
			div.tright {
				border-width: 0.5em 0 0.8em 1.4em;
				clear: right;
				float: right;
			}
			
			div.tleft {
				border-width: 0.5em 1.4em 0.8em 0;
				clear: left;
				float: left;
				margin-right: 0.5em;
			}
			
			img.thumbborder {
				border: 1px solid #DDDDDD;
			}
			
			/******************************************************************************* 
			 * Misc 
			 ******************************************************************************/
			.illegal {
				color: #CC3300;
				font-weight: normal;
			}
			
			.redirect {
				color: #FFCC00;
				font-weight: normal;
			}
			
			.magic-word {
				color: #9900CC;
				font-weight: bold;
			}
			
			/******************************************************************************* 
			 * Tables 
			 ******************************************************************************/
			table {
				font-size: 100%;
				color: black;
				background-color: white;
			}
			
			fieldset table {
				background: none;
			}
			
			table.wikitable {
				background: none repeat scroll 0 0 #F9F9F9;
				border: 1px solid #AAAAAA;
				border-collapse: collapse;
				margin: 1em 1em 1em 0;
			}
			
			.wikitable th,.wikitable td {
				border: 1px solid #AAAAAA;
				padding: 0.2em;
			}
			
			.wikitable th {
				background: none repeat scroll 0 0 #F2F2F2;
				text-align: center;
			}
			
			.wikitable caption {
				font-weight: bold;
			}
			
			table.collapsed tr.collapsable {
				display: none;
			}
			
			/******************************************************************************* 
			 * Debug 
			 ******************************************************************************/
			.unknown-node {
				color: #FFBBBB;
				font-weight: normal;
			}
			/******************************************************************************* 
			 * End of file 
			 ******************************************************************************/
		-->
	</style> 
 </head> 
 <body> 
  <div class="content"> 
   <h1 class="article-heading">Comparison of programming languages (mapping)</h1> 
   <div class="article-content"> 
    <p> <span class="unknown-node">{{ProgLangCompare}}</span> </p> 
    <div class="section"> 
     <h2>Language support</h2> 
     <div class="section-body"> 
      <p> <span class="unknown-node">{{Expand section|...}}</span> </p> 
      <p> The following is a comparison of <a href="associative array">associative arrays</a> (also &quot;mapping&quot;, &quot;hash&quot;, and &quot;dictionary&quot;) in various programming languages. </p> 
      <div class="section"> 
       <h3>Awk</h3> 
       <div class="section-body"> 
        <p> <a href="Awk">Awk</a> has built-in, language-level support for associative arrays. </p> 
        <p> For example: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Text&quot;&gt;</span> phonebook[&quot;Sally Smart&quot;] = &quot;555-9999&quot; phonebook[&quot;John Doe&quot;] = &quot;555-1212&quot; phonebook[&quot;J. Random Hacker&quot;] = &quot;555-1337&quot; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> You can also loop through an associated array as follows: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Text&quot;&gt;</span> for (name in phonebook) { print name, &quot; &quot;, phonebook[name] } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> You can also check if an element is in the associative array, and delete elements from an associative array. </p> 
        <p> Multi-dimensional associative arrays can be simulated in standard Awk using concatenation and e.g. SUBSEP: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Text&quot;&gt;</span> { # for every input line multi[$1 SUBSEP $2]++; } </p> 
        <ol> 
         <li></li> 
        </ol> 
        <p> END { for (x in multi) { split(x, arr, SUBSEP); print arr[1], arr[2], multi[x]; } } <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> C </h3> 
       <div class="section-body"> 
        <p> There is no standard implementation of an associative array in C, but a 3rd party library with BSD license is available <a href="http://www.cl.cam.ac.uk/~cwc22/hashtable/">here</a><span class="unknown-node">{{Dead link|...}}</span> . <a href="POSIX">POSIX</a> 1003.1-2001 describes the functions <code>hcreate()</code>, <code>hdestroy()</code> and <code>hsearch()</code>. </p> 
        <p> Another 3rd party library, <a href="http://uthash.sourceforge.net/">uthash</a>, also creates associative arrays from C structures. A structure represents a value, and one of the structure fields acts as the key. </p> 
        <p> Finally, the <a href="Glib">Glib</a> library also supports associative arrays, along with many other advanced data types and is the recommended implementation of the GNU Project.<a href="https://developer.gnome.org/glib/stable/glib-Hash-Tables.html">1</a> </p> 
        <p> Similar to <a href="Glib">Glib</a>, <a href="Apple Inc.">Apple</a>'s cross-platform <a href="Core Foundation">Core Foundation</a> framework provides several basic data types. In particular, there are reference counted CFDictionary and CFMutableDictionary. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>C#</h3> 
       <div class="section-body"> 
        <p> <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> Hashtable ht = new Hashtable(); ht.Add(&quot;testKey&quot;, &quot;AssociatedData&quot;); MessageBox.Show((string) ht[&quot;testKey&quot;]); <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> Dictionary&lt;int, string&gt; dic = new Dictionary&lt;int, string&gt;(); dic.Add(7, &quot;Bond&quot;); MessageBox.Show(dic[7]); <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> In the above sample the <code>Hashtable</code> class is only capable of associating a <code>String</code> key with a value of <code>Object</code> type. Because in .NET all types (except <a href="Pointer (computer programming)">pointers</a>) ultimately derive from <code>Object</code>, anything can be put into a <code>Hashtable</code>, even data of different types. This could lead to errors if consuming code expects data to be of a singular type. In the above code casting is required to convert the Object variables back to their original type. Additionally, casting value-types (structures such as integers) to <code>Object</code> to put into the <code>Hashtable</code> and casting them back requires boxing/unboxing which incurs both a slight performance penalty and pollutes the heap with garbage. This changes in C# 2.0 with generic hashtables called dictionaries. There are significant performance and reliability gains to these strongly typed collections because they do not require boxing/unboxing or explicit type casts and introduce compile-time type checks. C# 3.0 adds a shorthand notation for the dictionary initialization: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> Dictionary&lt;int, string&gt; = new Dictionary&lt;int, string&gt; { </p> 
        <pre>   { 7, &quot;Bond&quot; }
</pre> 
        <p> }; <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>C++</h3> 
       <div class="section-body"> 
        <p> <a href="C++">C++</a> also has a form of associative array called <a href="map (C++)"><code>std::map</code></a> (see <a href="Standard Template Library#Containers">Standard Template Library#Containers</a>). One could create a map with the same information as above using C++ with the following code: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Cpp&quot;&gt;</span> </p> 
        <ol> 
         <li>include <span class="unknown-node">&lt;map&gt;</span></li> 
         <li>include <span class="unknown-node">&lt;string&gt;</span></li> 
        </ol> 
        <pre>
</pre> 
        <p> int main() { std::map&lt;std::string, std::string&gt; phone_book; phone_book[&quot;Sally Smart&quot;] = &quot;555-9999&quot;; phone_book[&quot;John Doe&quot;] = &quot;555-1212&quot;; phone_book[&quot;J. Random Hacker&quot;] = &quot;553-1337&quot;; return 0; } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> You can iterate through the list with the following code: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Cpp&quot;&gt;</span> std::map&lt;std::string, std::string&gt;::iterator curr,end; for(curr = phone_book.begin(), end = phone_book.end(); curr != end; curr++) std::cout &lt;&lt; curr-&gt;first &lt;&lt; &quot; = &quot; &lt;&lt; curr-&gt;second &lt;&lt; std::endl; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> In C++, the <code>std::map</code> class is <a href="Generic programming#Templates in C.2B.2B">templated</a> which allows the <a href="data type">data types</a> of keys and values to be different for different <code>map</code> instances. For a given instance of the <code>map</code> class the keys must be of the same base type. The same must be true for all of the values. Although <code>std::map</code> is typically implemented using a <a href="self-balancing binary search tree">self-balancing binary search tree</a>, C++'s <a href="Technical Report 1">Technical Report 1</a> (TR1) defines a second map called <code><a href="std::tr1::unordered map">std::tr1::unordered map</a></code> with the algorithmic characteristics of a hash table. This is a common vendor extension to the STL as well, usually called <code>hash_map</code>, being available from such implementations as SGI and STLPort. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>ColdFusion</h3> 
       <div class="section-body"> 
        <p> You can use a <a href="ColdFusion">ColdFusion</a> structure to perform as an associative array. Here is a sample in ColdFusion: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;CFM&quot;&gt;</span> <span class="unknown-node">&lt;cfscript&gt;</span> phoneBook = StructNew(); phoneBook[&quot;Sally Smart&quot;] = &quot;555-9999&quot;; phoneBook[&quot;John Doe&quot;] = &quot;555-1212&quot;; phoneBook[&quot;J. Random Hacker&quot;] = &quot;555-1337&quot;; phoneBook[sName] = &quot;555-4321&quot;; phoneBook.UnknownComic = &quot;???&quot;; <span class="unknown-node">&lt;/cfscript&gt;</span> </p> 
        <p> <span class="unknown-node">&lt;cfoutput&gt;</span> </p> 
        <p> #phoneBook[&quot;UnknownComic&quot;]# </p> 
        <pre>      <span class="unknown-node">&lt;cfdump var=&quot;#phonebook#&quot; /&gt;</span>
</pre> 
        <p> <span class="unknown-node">&lt;/cfoutput&gt;</span> </p> 
        <p> <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> D </h3> 
       <div class="section-body"> 
        <p> <a href="D programming language">D</a> offers direct support for associative arrays in the core language ? they are implemented as a chaining hash table with binary trees.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> The equivalent example would be: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;D&quot;&gt;</span> int main() { string[ string ] phone_book; phone_book[&quot;Sally Smart&quot;] = &quot;555-9999&quot;; phone_book[&quot;John Doe&quot;] = &quot;555-1212&quot;; phone_book[&quot;J. Random Hacker&quot;] = &quot;553-1337&quot;; return 0; } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Keys and values can be any types, but all the keys in an associative array must be of the same type, and the same for values. </p> 
        <p> You can also loop through all properties and associated values, i.e. as follows: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;D&quot;&gt;</span> foreach (key, value; phone_book) { </p> 
        <pre>       writeln(&quot;Number for &quot; ~ key ~ &quot;: &quot; ~ value );
</pre> 
        <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> A property can be removed as follows: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;D&quot;&gt;</span> phone_book.remove(&quot;Sally Smart&quot;); <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Delphi</h3> 
       <div class="section-body"> 
        <p> Versions of <a href="Borland Delphi">Delphi</a> prior to 2009 do not offer direct support for associative arrays. However, you can simulate associative arrays using TStrings object. Here's an example: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Delphi&quot;&gt;</span> procedure TForm1.Button1Click(Sender: TObject); var </p> 
        <pre> DataField: TStrings;
 i: Integer;
</pre> 
        <p> begin </p> 
        <pre> DataField := TStringList.Create;
</pre> 
        <pre> DataField.Values['Sally Smart'] := '555-9999';
 DataField.Values['John Doe'] := '555-1212';
 DataField.Values['J. Random Hacker'] := '553-1337';
</pre> 
        <pre> // access an entry and display it in a message box
 ShowMessage(DataField.Values['Sally Smart']);
</pre> 
        <pre> // loop through the associative array 
 for i := 0 to DataField.Count - 1 do
 begin
   ShowMessage('Number for ' + DataField.Names[i] + ': ' + DataField.ValueFromIndex[i]);
 end;
</pre> 
        <pre> DataField.Free;
</pre> 
        <p> end; <span class="unknown-node">&lt;/source&gt;</span> Delphi 2009 introduced support for generics as well as several standard generic containers, including TDictionary. <span class="unknown-node">&lt;source lang=&quot;Delphi&quot;&gt;</span> uses </p> 
        <pre> SysUtils,
 Generics.Collections;
</pre> 
        <p> var </p> 
        <pre> PhoneBook: TDictionary&lt;string, string&gt;;
 Entry: TPair&lt;string, string&gt;;
</pre> 
        <p> begin </p> 
        <pre> PhoneBook := TDictionary&lt;string, string&gt;.Create;
 PhoneBook.Add('Sally Smart', '555-9999');
 PhoneBook.Add('John Doe', '555-1212');
 PhoneBook.Add('J. Random Hacker', '553-1337');
</pre> 
        <pre> for Entry in PhoneBook do
   Writeln(Format('Number for %s: %s',[Entry.Key, Entry.Value]));
</pre> 
        <p> end. <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Erlang</h3> 
       <div class="section-body"> 
        <p> Erlang offers many approaches to represent mappings, two of the most common in the standard library are keylists and dictionaries. </p> 
        <p> Keylists are lists of tuples, where the first element of each tuple is a key, and the second is a value. Functions for operating on keylists are provided in the <code>lists</code> module. </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Erlang&quot;&gt;</span> PhoneBook = [{&quot;Sally Smart&quot;, &quot;555-9999&quot;}, </p> 
        <pre>            {&quot;John Doe&quot;, &quot;555-1212&quot;},
            {&quot;J. Random Hacker&quot;, &quot;553-1337&quot;}].
</pre> 
        <p> <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Accessing an element of the keylist can be done with the <code>lists:keyfind/3</code> function: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Erlang&quot;&gt;</span> {_, Phone} = lists:keyfind(&quot;Sally Smart&quot;, 1, PhoneBook), io:format(&quot;Phone number: ~s~n&quot;, [Phone]). <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Dictionaries are implemented in the <code>dict</code> of the standard library. A new dictionary is created using the <code>dict:new/0</code> function and new key/value pairs are stored using the <code>dict:store/3</code> function: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Erlang&quot;&gt;</span> PhoneBook1 = dict:new(), PhoneBook2 = dict:store(&quot;Sally Smith&quot;, &quot;555-9999&quot;, Dict1), PhoneBook3 = dict:store(&quot;John Doe&quot;, &quot;555-1212&quot;, Dict2), PhoneBook = dict:store(&quot;J. Random Hacker&quot;, &quot;553-1337&quot;, Dict3). <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Such a serial initialization would be more idiomatically represented in Erlang with the appropriate function: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Erlang&quot;&gt;</span> PhoneBook = dict:from_list([{&quot;Sally Smith&quot;, &quot;555-9999&quot;}, {&quot;John Doe&quot;, &quot;555-1212&quot;}, </p> 
        <pre>                      {&quot;J. Random Hacker&quot;, &quot;553-1337&quot;}]).
</pre> 
        <p> <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> The dictionary can be accessed using the <code>dict:find/2</code> function: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Erlang&quot;&gt;</span> {ok, Phone} = dict:find(&quot;Sally Smith&quot;, PhoneBook), io:format(&quot;Phone: ~s~n&quot;, [Phone]). <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> In both cases, any Erlang term can be used as the key. Variations include the <code>orddict</code> module, implementing ordered dictionaries, and <code>gb_trees</code>, implementing general balanced trees. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>FoxPro</h3> 
       <div class="section-body"> 
        <p> <a href="Visual FoxPro">Visual FoxPro</a> implements mapping with the Collection Class. </p> 
        <p> <span class="unknown-node">&lt;pre&gt;...&lt;/pre&gt;</span> </p> 
        <p> GetKey returns 0 if the key is not found. </p> 
        <p> See Collection in FoxPro Help for all the details. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Go</h3> 
       <div class="section-body"> 
        <p> <a href="Go (programming language)">Go</a> has built-in, language-level support for associative arrays, called <i>maps</i>. A map's key type may only be a boolean, numeric, string, array, struct, pointer, interface, or channel type. A map type is written like this: <tt>map[keytype]valuetype</tt>. </p> 
        <p> Adding elements one at a time: <span class="unknown-node">&lt;source lang=&quot;Go&quot;&gt;</span> phone_book := make(map[string] string) // make an empty map phone_book[&quot;Sally Smart&quot;] = &quot;555-9999&quot; phone_book[&quot;John Doe&quot;] = &quot;555-1212&quot; phone_book[&quot;J. Random Hacker&quot;] = &quot;553-1337&quot; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> A map literal: <span class="unknown-node">&lt;source lang=&quot;Go&quot;&gt;</span> phone_book := map[string] string { &quot;Sally Smart&quot;: &quot;555-9999&quot;, &quot;John Doe&quot;: &quot;555-1212&quot;, &quot;J. Random Hacker&quot;: &quot;553-1337&quot;, } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Iterating over a map: <span class="unknown-node">&lt;source lang=&quot;Go&quot;&gt;</span> // over both keys and values for key, value := range phone_book { fmt.Printf(&quot;Number for %s: %s\n&quot;, key, value) } </p> 
        <p> // over just keys for key := range phone_book { fmt.Printf(&quot;Name: %s\n&quot;, key) } <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Haskell</h3> 
       <div class="section-body"> 
        <p> The <a href="Haskell (programming language)">Haskell</a> programming language's report only provides one kind of associative container: a list of pairs: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;haskell&quot;&gt;</span> m = [(&quot;Sally Smart&quot;, &quot;555-9999&quot;), (&quot;John Doe&quot;, &quot;555-1212&quot;), (&quot;J. Random Hacker&quot;, &quot;553-1337&quot;)] </p> 
        <p> main = print (lookup &quot;John Doe&quot; m) <span class="unknown-node">&lt;/source&gt;</span> output: </p> 
        <pre>Just &quot;555-1212&quot;
</pre> 
        <p> Note that the lookup function returns a &quot;Maybe&quot; value, which is &quot;Nothing&quot; if not found, or &quot;Just <i>result</i>&quot; when found. </p> 
        <p> <a href="Glasgow Haskell Compiler">GHC</a>, the most commonly used implementation of Haskell, provides two more types of associative containers. Other implementations might also provide these. </p> 
        <p> One is polymorphic functional maps (represented as immutable balanced binary trees): </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;haskell&quot;&gt;</span> import qualified Data.Map as M </p> 
        <p> m = M.insert &quot;Sally Smart&quot; &quot;555-9999&quot; M.empty m' = M.insert &quot;John Doe&quot; &quot;555-1212&quot; m m<i> = M.insert &quot;J. Random Hacker&quot; &quot;553-1337&quot; m'</i> </p> 
        <p> main = print (M.lookup &quot;John Doe&quot; m<i> :: Maybe String)</i> <span class="unknown-node">&lt;/source&gt;</span> output: </p> 
        <pre>Just &quot;555-1212&quot;
</pre> 
        <p> A specialized version for integer keys also exists as Data.IntMap. </p> 
        <p> Finally, a polymorphic hash table: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;haskell&quot;&gt;</span> import qualified Data.HashTable as H </p> 
        <p> main = do m &lt;- H.new (==) H.hashString </p> 
        <pre>         H.insert m &quot;Sally Smart&quot; &quot;555-9999&quot;
         H.insert m &quot;John Doe&quot; &quot;555-1212&quot;
         H.insert m &quot;J. Random Hacker&quot; &quot;553-1337&quot;
         foo &lt;- H.lookup m &quot;John Doe&quot;
         print foo
</pre> 
        <p> <span class="unknown-node">&lt;/source&gt;</span> output: </p> 
        <pre>Just &quot;555-1212&quot;
</pre> 
        <p> Lists of pairs and functional maps both provide a purely functional interface, which is more idiomatic in Haskell. In contrast, hash tables provide an imperative interface in the IO monad. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Java</h3> 
       <div class="section-body"> 
        <p> In <a href="Java (programming language)">Java</a> associative arrays are implemented as &quot;maps&quot;; they are part of the <a href="Java collections framework">Java collections framework</a>. Since <a href="Java Platform, Standard Edition">J2SE</a> 5.0 and the introduction of <a href="generic programming">generics</a> into Java, collections can have a type specified; for example, an associative array mapping strings to strings might be specified as follows: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> Map&lt;String, String&gt; phoneBook = new HashMap&lt;String, String&gt;(); phoneBook.put(&quot;Sally Smart&quot;, &quot;555-9999&quot;); phoneBook.put(&quot;John Doe&quot;, &quot;555-1212&quot;); phoneBook.put(&quot;J. Random Hacker&quot;, &quot;555-1337&quot;); <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> The <span class="unknown-node">{{Javadoc:SE|...}}</span> method is used to access a key; for example, the value of the expression <code>phoneBook.get(&quot;Sally Smart&quot;)</code> is <code>&quot;555-9999&quot;</code>. </p> 
        <p> This code above uses a hash map to store the associative array, by calling the constructor of the <span class="unknown-node">{{Javadoc:SE|...}}</span> class; however, since the code only uses methods common to the interface <span class="unknown-node">{{Javadoc:SE|...}}</span>, one could also use a self-balancing binary tree by calling the constructor of the <span class="unknown-node">{{Javadoc:SE|...}}</span> class (which implements the subinterface <span class="unknown-node">{{Javadoc:SE|...}}</span>), without changing the definition of the <code>phoneBook</code> variable or the rest of the code, or use a number of other underlying data structures that implement the <code>Map</code> interface. </p> 
        <p> The hash function in Java, used by HashMap and HashSet, is provided by the method <span class="unknown-node">{{Javadoc:SE|...}}</span>. Since every class in Java <a href="Inheritance (computer science)">inherits</a> from <span class="unknown-node">{{Javadoc:SE|...}}</span>, every object has a hash function. A class can <a href="Method overriding (programming)">override</a> the default implementation of <code>hashCode()</code> to provide a custom hash function based on the properties of the object. </p> 
        <p> The <code>Object</code> class also contains the method <span class="unknown-node">{{Javadoc:SE|...}}</span> that tests the object for equality with another object. Hashed data structures in Java rely on objects maintaining the following contract between their <code>hashCode()</code> and <code>equals()</code> methods: </p> 
        <p> For two objects <i>a</i> and <i>b</i>, <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> a.equals(b) == b.equals(a) if a.equals(b), then a.hashCode() == b.hashCode() <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> In order to maintain this contract, a class that overrides <code>equals()</code> must also override <code>hashCode()</code>, and maybe vice versa, so that <code>hashCode()</code> is based on the same properties (or a subset of the properties) as <code>equals()</code>. </p> 
        <p> A further contract that hashed data structures has with the object is that the results of the <code>hashCode()</code> and <code>equals()</code> methods will not change once the object has been inserted into the map. For this reason, it is generally a good practice to base the hash function on <a href="Immutable object">immutable</a> properties of the object. </p> 
        <p> Analogously, TreeMap, and other sorted data structures, requires that an ordering be defined on the data type. Either the data type must already have defined its own ordering, by implementing the <span class="unknown-node">{{Javadoc:SE|...}}</span> interface; or a custom <span class="unknown-node">{{Javadoc:SE|...}}</span> must be provided at the time the map is constructed. As with HashMap above, the relative ordering of keys in a TreeMap should not change once they have been inserted into the map. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>JavaScript</h3> 
       <div class="section-body"> 
        <p> JavaScript (and its standardized version: <a href="ECMAScript">ECMAScript</a>) is a <a href="Prototype-based programming">prototype-based</a> <a href="Object-oriented programming">object-oriented</a> language. In JavaScript an object is a mapping from property names to values?that is, an associative array with one caveat: since property names are strings, only string and (coerced) integer keys are allowed. Other than that difference, objects also include one feature unrelated to associative arrays: a prototype link to the object they inherit from. Doing a lookup for a property will forward the lookup to the prototype if the object does not define the property itself. </p> 
        <p> An object literal is written as <code>{ property1 : value1, property2 : value2, ... }</code>. For example: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;JavaScript&quot;&gt;</span> var myObject = { &quot;Sally Smart&quot; : &quot;555-9999&quot;, &quot;John Doe&quot; : &quot;555-1212&quot;, &quot;J. Random Hacker&quot; : &quot;553-1337&quot; }; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> If the property name is a valid identifier, the quotes can be omitted, e.g.: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;JavaScript&quot;&gt;</span> var myOtherObject = { foo : 42, bar : false } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Lookup is written using property access notation, either square brackets, which always works, or dot notation, which only works for identifier keys: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;JavaScript&quot;&gt;</span> myObject[&quot;John Doe&quot;] myOtherObject.foo <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> You can also loop through all enumerable properties and associated values as follows: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;JavaScript&quot;&gt;</span> for(var property in myObject) { var value = myObject[property]; alert(&quot;myObject[&quot; + property + &quot;] = &quot; + value); } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> A property can be removed as follows: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;JavaScript&quot;&gt;</span> delete myObject[&quot;Sally Smart&quot;]; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> As mentioned before, properties are strings. However, since every native object and primitive can be implicitly converted to a string, you can do: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;JavaScript&quot;&gt;</span> myObject[1] // key is &quot;1&quot;; note that myObject[1] == myObject['1'] myObject<a href="'a','b'">'a','b'</a> // key is &quot;a,b&quot; myObject[{toString:function(){return 'hello world';}}] // key is &quot;hello world&quot; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Any object, including built-in objects such as Array, can be dynamically extended with new properties. For example: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;JavaScript&quot;&gt;</span> Array.prototype.removeAllObjects = function () { /* ... */ } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> In modern JavaScript it's considered bad form to use the Array type as an associative array. Consensus is that the Object type is best for this purpose. The reasoning behind this is that if Array is extended via prototype and Object is kept pristine, 'for(in)' loops will work as expected on associative 'arrays'. This issue has been drawn into focus by the popularity of JavaScript frameworks that make heavy and sometimes indiscriminate use of prototype to extend JavaScript's inbuilt types. </p> 
        <p> See <a href="http://blog.metawrap.com/blog/June6thIsJavaScriptArrayAndObjectprototypeAwarenessDay.aspx">JavaScript Array And Object Prototype Awareness Day</a> for more information on the issue. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>KornShell 93 (and compliant shells: ksh93, zsh, bash4...)</h3> 
       <div class="section-body"> 
        <p> Definition: </p> 
        <pre>typeset -A phonebook; # ksh93
declare -A phonebook; # bash4
phonebook=([&quot;Sally Smart&quot;]=&quot;555-9999&quot; [&quot;John Doe&quot;]=&quot;555-1212&quot; [&quot;<a href="J. Random Hacker">J. Random Hacker</a>&quot;]=&quot;555-1337&quot;);
</pre> 
        <p> Dereference: </p> 
        <pre>${phonebook[&quot;John Doe&quot;]};
</pre> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Lisp</h3> 
       <div class="section-body"> 
        <p> <a href="Lisp programming language">Lisp</a> was originally conceived as a &quot;LISt Processing&quot; language, and one of its most important data types is the linked list, which can be treated as an association list (&quot;alist&quot;). </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Lisp&quot;&gt;</span> '((&quot;Sally Smart&quot; . &quot;555-9999&quot;) </p> 
        <pre> (&quot;John Doe&quot; . &quot;555-1212&quot;)
 (&quot;J. Random Hacker&quot; . &quot;553-1337&quot;))
</pre> 
        <p> <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> The syntax <code>(x . y)</code> is used to indicate a <a href="cons"><code>cons</code>ed</a> pair. Keys and values need not be the same type within an alist. Lisp and Scheme provide operators such as <code>assoc</code> to manipulate alists in ways similar to associative arrays. </p> 
        <p> Because of their linear nature, alists are used for relatively small sets of data. <a href="Common Lisp">Common Lisp</a> also supports a <a href="hash table">hash table</a> data type, and for <a href="Scheme (programming language)">Scheme</a> they are implemented in <a href="Scheme Requests for Implementation">SRFI</a> 69. Hash tables have greater overhead than alists, but provide much faster access when there are many elements. </p> 
        <p> It is easy to construct composite abstract data types in Lisp, using structures and/or the object-oriented programming features, in conjunction with lists, arrays, and hash tables. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>LPC</h3> 
       <div class="section-body"> 
        <p> <a href="LPC (programming language)">LPC</a> implements associative arrays as a fundamental type known as either map or mapping, depending on the driver. The keys and values can be of any type. A mapping literal is written as <code>([ key_1 : value_1, key_2 : value_2 ])</code>. Procedural use looks like: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;C&quot;&gt;</span> mapping phone_book = ([]); phone_book[&quot;Sally Smart&quot;] = &quot;555-9999&quot;; phone_book[&quot;John Doe&quot;] = &quot;555-1212&quot;; phone_book[&quot;J. Random Hacker&quot;] = &quot;555-1337&quot;; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Mappings are accessed for reading using the indexing operator in the same way as they are for writing, as shown above. So phone_book[&quot;Sally Smart&quot;] would return the string &quot;555-9999&quot;, and phone_book[&quot;John Smith&quot;] would return 0. Testing for presence is done using the function member(), e.g. <code>if(member(phone_book, &quot;John Smith&quot;)) write(&quot;John Smith is listed.\n&quot;);</code> </p> 
        <p> Deletion is accomplished using a function called either m_delete() or map_delete(), depending on the driver, used like: <code>m_delete(phone_book, &quot;Sally Smart&quot;);</code> </p> 
        <p> LPC drivers of the &quot;Amylaar&quot; family implement multivalued mappings using a secondary, numeric index. (Drivers of the MudOS family do not support multivalued mappings.) Example syntax: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;C&quot;&gt;</span> mapping phone_book = ([:2]); phone_book[&quot;Sally Smart&quot;, 0] = &quot;555-9999&quot;; phone_book[&quot;Sally Smart&quot;, 1] = &quot;99 Sharp Way&quot;; phone_book[&quot;John Doe&quot;, 0] = &quot;555-1212&quot;; phone_book[&quot;John Doe&quot;, 1] = &quot;3 Nigma Drive&quot;; phone_book[&quot;J. Random Hacker&quot;, 0] = &quot;555-1337&quot;; phone_book[&quot;J. Random Hacker&quot;, 1] = &quot;77 Massachusetts Avenue&quot;; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> LPC drivers modern enough to support a foreach() construct allow iteration over their mapping types using it. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Lua</h3> 
       <div class="section-body"> 
        <p> In <a href="Lua programming language">Lua</a>, table is a fundamental type that can be used either as array (numerical index, fast) or as associative array. The keys and values can be of any type, except nil. The following focuses on non-numerical indexes. </p> 
        <p> A table literal is written as <code>{ value, key = value, [index] = value, [&quot;non id string&quot;] = value }</code>. For example: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Lua&quot;&gt;</span> phone_book = { [&quot;Sally Smart&quot;] = &quot;555-9999&quot;, [&quot;John Doe&quot;] = &quot;555-1212&quot;, [&quot;J. Random Hacker&quot;] = &quot;553-1337&quot;, -- Trailing comma is OK } </p> 
        <p> aTable = { -- Table as value subTable = { 5, 7.5, k = true }, -- key is &quot;subTable&quot; -- Function as value ['John Doe'] = function (age) if age &lt; 18 then return &quot;Young&quot; else return &quot;Old!&quot; end end, -- Table and function (and other types) can also be used as keys } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> If the key is a valid identifier (not a keyword), the quotes can be omitted. They are case sensitive. </p> 
        <p> Lookup is written using either square brackets, which always works, or dot notation, which only works for identifier keys: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Lua&quot;&gt;</span> print(aTable[&quot;John Doe&quot;](45)) x = aTable.subTable.k <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> You can also loop through all keys and associated values with iterators or for loops: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Lua&quot;&gt;</span> simple = { [true] = 1, [false] = 0, [3.14] = math.pi, x = 'x', [&quot;!&quot;] = 42 } function FormatElement(key, value) return &quot;[&quot; .. tostring(key) .. &quot;] = &quot; .. value .. &quot;, &quot; end -- Iterate on all keys table.foreach(simple, function (k, v) io.write(FormatElement(k, v)) end) print&quot;&quot; for k, v in pairs(simple) do io.write(FormatElement(k, v)) end print&quot;&quot; k= nil repeat k, v = next(simple, k) if k ~= nil then io.write(FormatElement(k, v)) end until k == nil print&quot;&quot; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> An entry can be removed by setting it to nil: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Lua&quot;&gt;</span> simple.x = nil <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Likewise, you can overwrite values or add them: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Lua&quot;&gt;</span> simple['%'] = &quot;percent&quot; simple['!'] = 111 <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>MUMPS</h3> 
       <div class="section-body"> 
        <p> In <a href="MUMPS">MUMPS</a> every array is an associative array. The built-in, language-level, direct support for associative arrays applies to private, process-specific arrays stored in memory called &quot;locals&quot; as well as to the permanent, shared arrays stored on disk which are available concurrently by multiple jobs. The name for globals is preceded by the circumflex &quot;^&quot; to distinguish it from local variable names. </p> 
        <pre>SET ^phonebook(&quot;Sally Smart&quot;)=&quot;555-9999&quot;      ;; storing permanent data
SET phonebook(&quot;John Doe&quot;)=&quot;555-1212&quot;          ;; storing temporary data
SET phonebook(&quot;J. Random Hacker&quot;)=&quot;553-1337&quot;  ;;storing temporary data
MERGE ^phonebook=phonebook                    ;;copying temporary data into permanent data
</pre> 
        <p> To access the value of an element, simply requires using the name with the subscript: </p> 
        <pre>WRITE &quot;Phone Number :&quot;,^phonebook(&quot;Sally Smart&quot;),!
</pre> 
        <p> You can also loop through an associated array as follows: </p> 
        <pre>SET NAME=&quot;&quot;
FOR  S NAME=$ORDER(^phonebook(NAME)) QUIT:NAME=&quot;&quot;  WRITE NAME,&quot;  Phone Number :&quot;,^phonebook(NAME),!
</pre> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Objective-C (Cocoa/GNUstep)</h3> 
       <div class="section-body"> 
        <p> <a href="Cocoa (API)">Cocoa (API)</a> and <a href="GNUstep">GNUstep</a> handle associative arrays using <code>NSMutableDictionary</code> (a mutable version of <code>NSDictionary</code>) class cluster. This class allows assignments between any two objects to be made. A copy of the key object is made before it is inserted into <code>NSMutableDictionary</code>, therefore the keys must conform to the <code>NSCopying</code> protocol. When being inserted to a dictionary, the value object receives a retain message to increase its reference count. The value object will receive the release message when it will be deleted from the dictionary (both explicitly or by adding to the dictionary a different object with the same key). </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;ObjC&quot;&gt;</span> NSMutableDictionary *aDictionary = [[NSMutableDictionary alloc] init]; [aDictionary setObject:@&quot;555-9999&quot; forKey:@&quot;Sally Smart&quot;]; [aDictionary setObject:@&quot;555-1212&quot; forKey:@&quot;John Doe&quot;]; [aDictionary setObject:@&quot;553-1337&quot; forKey:@&quot;Random Hacker&quot;]; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> To access assigned objects this command may be used: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;ObjC&quot;&gt;</span> id anObject = [aDictionary objectForKey:@&quot;Sally Smart&quot;]; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> All keys or values can be simply enumerated using <code>NSEnumerator</code> </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;ObjC&quot;&gt;</span> NSEnumerator *keyEnumerator = [aDictionary keyEnumerator]; id key; while ((key = [keyEnumerator nextObject])) { </p> 
        <pre> // ... process it here ...
</pre> 
        <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> On Mac OS X 10.5+ and iPhone OS, dictionary keys can also be enumerated more concisely using this <a href="http://developer.apple.com/documentation/Cocoa/Reference/NSFastEnumeration_protocol/">NSFastEnumeration</a> construct: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;ObjC&quot;&gt;</span> for (id key in aDictionary) { </p> 
        <pre> // ... process it here ...
</pre> 
        <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> What is even more practical, structured data graphs may be easily created using <a href="Cocoa (API)">Cocoa</a>, especially <code>NSDictionary</code> (<code>NSMutableDictionary</code>). This can be illustrated with this compact example: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;ObjC&quot;&gt;</span> NSDictionary *aDictionary = </p> 
        <pre>      [NSDictionary dictionaryWithObjectsAndKeys:
                          [NSDictionary dictionaryWithObjectsAndKeys:
                                  @&quot;555-9999&quot;, @&quot;Sally Smart&quot;,
                                  @&quot;555-1212&quot;, @&quot;John Doe&quot;,
                                  nil], @&quot;students&quot;,
                          [NSDictionary dictionaryWithObjectsAndKeys:
                                  @&quot;553-1337&quot;, @&quot;Random Hacker&quot;,
                                  nil], @&quot;hackers&quot;,
                          nil];
</pre> 
        <p> <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> And relevant fields can be quickly accessed using key paths: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;ObjC&quot;&gt;</span> id anObject = [aDictionary valueForKeyPath:@&quot;students.Sally Smart&quot;]; <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>OCaml</h3> 
       <div class="section-body"> 
        <p> The <a href="OCaml">OCaml</a> programming language provides three different associative containers. The simplest is a list of pairs: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;OCaml&quot;&gt;</span> </p> 
        <ol> 
         <li> let m = [</li> 
        </ol> 
        <p> &quot;Sally Smart&quot;, &quot;555-9999&quot;; &quot;John Doe&quot;, &quot;555-1212&quot;; &quot;J. Random Hacker&quot;, &quot;553-1337&quot;];; val m : (string * string) list = [ (&quot;Sally Smart&quot;, &quot;555-9999&quot;); (&quot;John Doe&quot;, &quot;555-1212&quot;); (&quot;J. Random Hacker&quot;, &quot;553-1337&quot;) ] </p> 
        <ol> 
         <li> List.assoc &quot;John Doe&quot; m;;</li> 
        </ol> 
        <p> - : string = &quot;555-1212&quot; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> The second is a polymorphic hash table: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;OCaml&quot;&gt;</span> </p> 
        <ol> 
         <li> let m = Hashtbl.create 3;;</li> 
        </ol> 
        <p> val m : ('_a, '_b) Hashtbl.t = <span class="unknown-node">&lt;abstr&gt;</span> </p> 
        <ol> 
         <li> Hashtbl.add m &quot;Sally Smart&quot; &quot;555-9999&quot;;</li> 
        </ol> 
        <pre> Hashtbl.add m &quot;John Doe&quot; &quot;555-1212&quot;;
 Hashtbl.add m &quot;J. Random Hacker&quot; &quot;553-1337&quot;;;
</pre> 
        <p> - : unit = () </p> 
        <ol> 
         <li> Hashtbl.find m &quot;John Doe&quot;;;</li> 
        </ol> 
        <p> - : string = &quot;555-1212&quot; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> The code above uses OCaml's default hash function <code>Hashtbl.hash</code>, which is defined automatically for all types. If you wanted to use your own hash function, you can use the functor interface <code>Hashtbl.Make</code> to create a module, like with <code>Map</code> below. </p> 
        <p> Finally, functional maps (represented as immutable balanced binary trees): </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;OCaml&quot;&gt;</span> </p> 
        <ol> 
         <li> module StringMap = Map.Make(String);;</li> 
        </ol> 
        <p> ... </p> 
        <ol> 
         <li> let m = StringMap.add &quot;Sally Smart&quot; &quot;555-9999&quot; StringMap.empty</li> 
        </ol> 
        <pre> let m = StringMap.add &quot;John Doe&quot; &quot;555-1212&quot; m
 let m = StringMap.add &quot;J. Random Hacker&quot; &quot;553-1337&quot; m;;
</pre> 
        <p> val m : string StringMap.t = <span class="unknown-node">&lt;abstr&gt;</span> </p> 
        <ol> 
         <li> StringMap.find &quot;John Doe&quot; m;;</li> 
        </ol> 
        <pre>- : string = &quot;555-1212&quot;
</pre> 
        <p> <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Note that in order to use <code>Map</code>, you have to provide the functor <code>Map.Make</code> with a module which defines the key type and the comparison function. The third-party library ExtLib provides a polymorphic version of functional maps, called <a href="http://ocaml-extlib.googlecode.com/svn/doc/apiref/PMap.html">PMap</a>, where you provide the comparison function when creating the map. </p> 
        <p> Lists of pairs and functional maps both provide a purely functional interface. In contrast, hash tables provide an imperative interface. For many operations, hash tables are significantly faster than lists of pairs and functional maps. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Optimj</h3> 
       <div class="section-body"> 
        <p> <span class="unknown-node">{{Refimprove section|...}}</span> The <a href="OptimJ">OptimJ</a> programming language is an extension of Java 5. As java, Optimj provides maps. But, OptimJ also provides true associative arrays: java arrays are indexed with 0-based integers; associative arrays are indexed with any collection of keys. </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> String[String] phoneBook = { &quot;Sally Smart&quot; -&gt; &quot;555-9999&quot;, &quot;John Doe&quot; -&gt; &quot;555-1212&quot;, &quot;J. Random Hacker&quot; -&gt; &quot;553-1337&quot; }; </p> 
        <p> // String[String] is not a java type but an optimj type: // associative array of strings indexed by strings. </p> 
        <p> // iterate over the values for(String number : phoneBook) { System.out.println(number); } </p> 
        <p> // The previous statement prints: &quot;555-9999&quot; &quot;555-1212&quot; &quot;553-1337&quot; </p> 
        <p> // iterate over the keys for(String name : phoneBook.keys) { System.out.println(name + &quot; -&gt; &quot; + phoneBook[name]); } // phoneBook[name] access a value by a key (it looks like java array access) // i.e. phoneBook[&quot;John Doe&quot;] returns &quot;555-1212&quot; </p> 
        <p> <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Of course, it is possible to define multi-dimensional arrays, to mix java array and associative arrays, to mix maps and associative arrays. </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> </p> 
        <pre>int[String][][double] a;
java.util.Map&lt;String[Object], Integer&gt; b;
</pre> 
        <p> <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Perl</h3> 
       <div class="section-body"> 
        <p> <a href="Perl">Perl</a> has built-in, language-level support for associative arrays. Modern Perl vernacular refers to associative arrays as <i>hashes</i>; the term <i>associative array</i> is found in older documentation, but is considered somewhat archaic. Perl hashes are flat: keys are strings and values are scalars. However, values may be <a href="reference (computer science)">references</a> to arrays or other hashes, and the standard Perl module Tie::RefHash enables hashes to be used with reference keys. </p> 
        <p> A hash variable is marked by a <code>%</code> <a href="sigil (computer programming)">sigil</a>, to distinguish it from scalar, array and other data types. A hash literal is a key-value list, with the preferred form using Perl's <code>=&gt;</code> token, which is mostly semantically identical to the comma and makes the key-value association clearer: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Perl&quot;&gt;</span> %phone_book = ( 'Sally Smart' =&gt; '555-9999', 'John Doe' =&gt; '555-1212', 'J. Random Hacker' =&gt; '553-1337', ); <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Accessing a hash element uses the syntax <code>$hash_name{$key}</code> ? the key is surrounded by <i>curly braces</i> and the hash name is prefixed by a <code>$</code>, indicating that the hash element itself is a <i>scalar</i> value, even though it is part of a hash. The value of <code>$phone_book{'John Doe'}</code> is <code>'555-1212'</code>. The <code>%</code> sigil is only used when referring to the hash as a whole, such as when asking for <code>keys %phone_book</code>. </p> 
        <p> The list of keys and values can be extracted using the built-in functions <code>keys</code> and <code>values</code>, respectively. So, for example, to print all the keys of a hash: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Perl&quot;&gt;</span> foreach $name (keys %phone_book) { print $name, &quot;\n&quot;; } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> One can iterate through (key, value) pairs using the <code>each</code> function: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Perl&quot;&gt;</span> while (($name, $number) = each %phone_book) { print 'Number for ', $name, ': ', $number, &quot;\n&quot;; } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> A hash <i>reference</i>, which is a scalar value that points to a hash, is specified in literal form using curly braces as delimiters, with syntax otherwise similar to specifying a hash literal: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Perl&quot;&gt;</span> $phone_book = { 'Sally Smart' =&gt; '555-9999', 'John Doe' =&gt; '555-1212', 'J. Random Hacker' =&gt; '553-1337', }; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Values in a hash reference are accessed using the dereferencing operator: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Perl&quot;&gt;</span> print $phone_book-&gt;{'Sally Smart'}; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> When the hash contained in the hash reference needs to be referred to as a whole, as with the <code>keys</code> function, the syntax is as follows: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Perl&quot;&gt;</span> foreach $name (keys %{$phone_book}) { print 'Number for ', $name, ': ', $phone_book-&gt;{$name}, &quot;\n&quot;; } <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> PHP </h3> 
       <div class="section-body"> 
        <p> <a href="PHP">PHP</a>'s built-in array type is in reality an associative array. Even when using numerical indexes, PHP internally stores it as an associative array.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> This is why one in PHP can have non-consecutive numerically indexed arrays. The keys have to be integer or string (floating point numbers are truncated to integer), while values can be of arbitrary types, including other arrays and objects. The arrays are heterogeneous; a single array can have keys of different types. PHP's associative arrays can be used to represent trees, lists, stacks, queues and other common data structures not built into PHP. </p> 
        <p> An associative array can be declared using the following syntax: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;PHP&quot;&gt;</span> $phonebook = array(); $phonebook['Sally Smart'] = '555-9999'; $phonebook['John Doe'] = '555-1212'; $phonebook['J. Random Hacker'] = '555-1337'; </p> 
        <p> // or </p> 
        <p> $phonebook = array( </p> 
        <pre>   'Sally Smart'      =&gt; '555-9999',
   'John Doe'         =&gt; '555-1212',
   'J. Random Hacker' =&gt; '555-1337',
</pre> 
        <p> ); </p> 
        <p> // or </p> 
        <p> $phonebook['contacts']['Sally Smart']['number'] = '555-9999'; $phonebook['contacts']['John Doe']['number'] = '555-1212'; $phonebook['contacts']['J. Random Hacker']['number'] = '555-1337'; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> PHP can loop through an associative array as follows: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;PHP&quot;&gt;</span> foreach($phonebook as $name =&gt; $number) { </p> 
        <pre>   echo 'Number for ', $name, ': ', $number, &quot;\n&quot;;
</pre> 
        <p> } </p> 
        <p> // For the last array example it is used like this foreach($phonebook['contacts'] as $name =&gt; $num) { </p> 
        <pre>  echo 'Name: ', $name, ', number: ', $num['number'], &quot;\n&quot;;
</pre> 
        <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> PHP has an <a href="http://php.net/array">extensive set of functions</a> to operate on arrays. </p> 
        <p> If you want an associative array that can use objects as keys instead of strings and integers, you can use the <a href="http://php.net/SplObjectStorage">SplObjectStorage</a> class from the Standard PHP Library (SPL). </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Pike</h3> 
       <div class="section-body"> 
        <p> <a href="Pike (programming language)">Pike</a> has built-in support for Associative Arrays, which are referred to as mappings. Mappings are created as follows: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Pike&quot;&gt;</span> mapping(string:string) phonebook = ([ &quot;Sally Smart&quot;:&quot;555-9999&quot;, &quot;John Doe&quot;:&quot;555-1212&quot;, &quot;J. Random Hacker&quot;:&quot;555-1337&quot; ]); <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Accessing and testing for presence in mappings is done using the indexing operator. So <code>phonebook[&quot;Sally Smart&quot;]</code> would return the string <code>&quot;555-9999&quot;</code>, and <code>phonebook[&quot;John Smith&quot;]</code> would return 0. </p> 
        <p> Iterating through a mapping can be done using either foreach: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Text&quot;&gt;</span> foreach(phonebook; string key; string value) { write(&quot;%s:%s\n&quot;, key, value); } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Or using an iterator object: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Text&quot;&gt;</span> Mapping.Iterator i = get_iterator(phonebook); while (i-&gt;index()) { write(&quot;%s:%s\n&quot;, i-&gt;index(), i-&gt;value()); i-&gt;next(); } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Elements of a mapping can be removed using m_delete, which returns the value of the removed index: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Text&quot;&gt;</span> string sallys_number = m_delete(phonebook, &quot;Sally Smart&quot;); <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>PostScript</h3> 
       <div class="section-body"> 
        <p> In <a href="PostScript">PostScript</a>, associative arrays are called dictionaries. In Level 1 PostScript they must be created explicitly, but Level 2 introduced direct declaration using the double-brace syntax: </p> 
        <p> <code> </code> </p> 
        <pre><code> % Level 1 declaration</code>
<code> 3 dict dup begin</code>
<code>   /red   (rouge) def</code>
<code>   /green (vert)  def</code>
<code>   /blue  (bleu)  def</code>
<code> end</code>
</pre> 
        <code> </code> 
        <pre><code> % Level 2 declaration</code>
<code> &lt;&lt;</code>
<code>   /red   (rot)</code>
<code>   /green (gruen)</code>
<code>   /blue  (blau)</code>
<code> &gt;&gt;</code>
</pre> 
        <code> </code> 
        <pre><code> % Both methods leave the dictionary on the operand stack</code>
</pre> 
        <p> Dictionaries can be accessed directly using <b>get</b> or implicitly by placing the dictionary on the dictionary stack using <b>begin</b>: </p> 
        <p> <code> </code> </p> 
        <pre><code> % With the previous two dictionaries still on the operand stack</code>
<code> /red get print    % outputs 'rot'</code>
</pre> 
        <code> </code> 
        <pre><code> begin</code>
<code> green print       % outputs 'vert'</code>
<code> end</code>
</pre> 
        <p> Dictionary contents can be iterated through using <b>forall</b>, though not in any particular order: </p> 
        <p> <code> </code> </p> 
        <pre><code> % Level 2 example</code>
<code> &lt;&lt;</code>
<code>   /This  1</code>
<code>   /That  2</code>
<code>   /Other 3</code>
<code> &gt;&gt; {exch =print ( is ) print ==} forall</code>
</pre> 
        <p> May well output: <code> </code> </p> 
        <pre><code> That is 2</code>
<code> This is 1</code>
<code> Other is 3</code>
</pre> 
        <p> Dictionaries can be augmented (up to their defined size only in Level 1) or altered using <b>put</b>, and entries can be removed using <b>undef</b>: <code> </code> </p> 
        <pre><code> % define a dictionary for easy reuse:</code>
<code> /MyDict &lt;&lt;</code>
<code>   /rouge (red)</code>
<code>   /vert (gruen)</code>
<code> &gt;&gt; def</code>
</pre> 
        <code> </code> 
        <pre><code> % add to it</code>
<code> MyDict /bleu (blue) put</code>
</pre> 
        <code> </code> 
        <pre><code> % change it</code>
<code> MyDict /vert (green) put</code>
</pre> 
        <code> </code> 
        <pre><code> % remove something</code>
<code> MyDict /rouge undef</code>
</pre> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Python</h3> 
       <div class="section-body"> 
        <p> In <a href="Python (programming language)">Python</a>, associative arrays are called <i><a href="Python syntax and semantics#Collection types">dictionaries</a></i>. Dictionary literals are marked with curly braces: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Python&quot;&gt;</span> phonebook = { 'Sally Smart' : '555-9999', 'John Doe' : '555-1212', 'J. Random Hacker' : '553-1337' } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> To access an entry in Python simply use the array indexing operator. For example, the expression <code>phonebook['Sally Smart']</code> would return <code>'555-9999'</code>. </p> 
        <p> An example loop <a href="iterator#Python">iterating</a> through all the keys of the dictionary: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Python&quot;&gt;</span> for key in phonebook: print key, phonebook[key] <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Iterating through (key, value) tuples: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Python&quot;&gt;</span> for key, value in phonebook.items(): print key, value <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Dictionaries can also be constructed with the <code>dict</code> builtin, which is most commonly found inside list comprehensions and generator expressions, and it takes a key-value list: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Python&quot;&gt;</span> dict((key, value) for key, value in phonebook.items() if 'J' in key) <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Dictionary keys can be individually deleted using the del statement. The corresponding value can be returned before the key-value pair are deleted using the pop method of dict types: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Python&quot;&gt;</span> del phonebook['John Doe'] val = phonebook.pop('Sally Smart') assert phonebook.keys() == ['J. Random Hacker'] # Only one key left <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Python 3.0 also supports dictionary comprehensions, a compact syntax for generating a dictionary from any iterator: <span class="unknown-node">&lt;source lang=&quot;Python&quot;&gt;</span> square_dict={i:i*i for i in range(5)} assert square_dict == {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>REXX</h3> 
       <div class="section-body"> 
        <p> In <a href="REXX">REXX</a>, associative arrays are called <i>Stem variables</i> or <i>Compound variables</i>. </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;REXX&quot;&gt;</span> KEY = 'Sally Smart' PHONEBOOK.KEY = '555-9999' KEY = 'John Doe' PHONEBOOK.KEY = '555-1212' KEY = 'J. Ramdon Hacker' PHONEBOOK.KEY = '553-1337' <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Stem variables with numeric keys typically start at 1 and go up from there. The 0 key stem variable is used (by convention) as the count of items in the whole stem. </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;REXX&quot;&gt;</span> NAME.1 = 'Sally Smart' NAME.2 = 'John Doe' NAME.3 = 'J. Random Hacker' NAME.0 = 3 <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> <a href="REXX">REXX</a> has no easy way of automatically accessing the keys for a stem variable and typically the keys are stored in a separate associative array with numeric keys. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Ruby </h3> 
       <div class="section-body"> 
        <p> In <a href="Ruby programming language">Ruby</a> a <a href="hash table">hash</a> is used as follows: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Ruby&quot;&gt;</span> phonebook = { 'Sally Smart' =&gt; '555-9999', 'John Doe' =&gt; '555-1212', 'J. Random Hacker' =&gt; '553-1337' } </p> 
        <p> phonebook['John Doe']; #produces this -&gt; '555-1212' <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Ruby supports hash looping and iteration with the following syntax: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Ruby&quot;&gt;</span> </p> 
        <ol> 
         <li> 
          <ol> 
           <li> 
            <ol> 
             <li> iterate over keys and values</li> 
            </ol> </li> 
          </ol> </li> 
        </ol> 
        <p> phonebook.each {|key, value| puts key + &quot; =&gt; &quot; + value} </p> 
        <ol> 
         <li> 
          <ol> 
           <li> 
            <ol> 
             <li> iterate keys only</li> 
            </ol> </li> 
          </ol> </li> 
        </ol> 
        <p> phonebook.each_key {|key| puts key} </p> 
        <ol> 
         <li> 
          <ol> 
           <li> 
            <ol> 
             <li> iterate values only</li> 
            </ol> </li> 
          </ol> </li> 
        </ol> 
        <p> phonebook.each_value {|value| puts value} <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>S-Lang</h3> 
       <div class="section-body"> 
        <p> <a href="S-Lang (programming language)">S-Lang</a> has an associative array type. </p> 
        <p> For example: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;C&quot;&gt;</span> phonebook = Assoc_Type[]; phonebook[&quot;Sally Smart&quot;] = &quot;555-9999&quot; phonebook[&quot;John Doe&quot;] = &quot;555-1212&quot; phonebook[&quot;J. Random Hacker&quot;] = &quot;555-1337&quot; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> You can also loop through an associated array in a number of ways. Here is one </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;C&quot;&gt;</span> foreach name (phonebook) { vmessage (&quot;%s %s&quot;, name, phonebook[name]; } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> To print a sorted-list, it is better to take advantage of S-lang's strong support for standard arrays: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;C&quot;&gt;</span> keys = assoc_get_keys(phonebook); i = array_sort(keys); vals = assoc_get_values(phonebook); array_map (Void_Type, &amp;vmessage, &quot;%s %s&quot;, keys[i], vals[i]); <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Scala</h3> 
       <div class="section-body"> 
        <p> <a href="Scala (programming language)">Scala</a> provides an immutable Map class as part of the scala.collection framework: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Scala&quot;&gt;</span> val phonebook = Map(&quot;Sally Smart&quot; -&gt; &quot;555-9999&quot;, </p> 
        <pre> &quot;John Doe&quot; -&gt; &quot;555-1212&quot;,
 &quot;J. Random Hacker&quot; -&gt; &quot;553-1337&quot;)
</pre> 
        <p> <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Scala's <a href="type inference">type inference</a> will work out that this is a <code>Map[String, String]</code>. To access the array: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Scala&quot;&gt;</span> phonebook.get(&quot;Sally Smart&quot;) <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> This returns an Option type, Scala's equivalent of a <a href="Monad_(functional_programming)#The Maybe_monad">the Maybe monad</a> in Haskell. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Smalltalk</h3> 
       <div class="section-body"> 
        <p> In <a href="Smalltalk">Smalltalk</a> a dictionary is used: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Smalltalk&quot;&gt;</span> phonebook := Dictionary new. phonebook at: 'Sally Smart' put: '555-9999'. phonebook at: 'John Doe' put: '555-1212'. phonebook at: 'J. Random Hacker' put: '553-1337'. <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> To access an entry the message <code>#at:</code> is sent to the dictionary object. </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Smalltalk&quot;&gt;</span> phonebook at: 'Sally Smart' <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> gives </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Text&quot;&gt;</span> </p> 
        <pre>'555-9999'
</pre> 
        <p> <span class="unknown-node">&lt;/source&gt;</span> Dictionary hashes/compares based on equality and holds <a href="Garbage collection (computer science)#Strong and Weak references">strong references</a> to both key and value. Variants exist which hash/compare on identity (IdentityDictionary) or keep <a href="Garbage collection (computer science)#Strong and Weak references">weak references</a> (WeakKeyDictionary / WeakValueDictionary). </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>SNOBOL</h3> 
       <div class="section-body"> 
        <p> <a href="SNOBOL">SNOBOL</a> is one of the first (if not the first) programming languages to use associative arrays. Associative arrays in <a href="SNOBOL">SNOBOL</a> are called Tables. </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Text&quot;&gt;</span> PHONEBOOK = TABLE() PHONEBOOK['Sally Smart'] = '555-9999' PHONEBOOK['John Doe'] = '555-1212' PHONEBOOK['J. Random Hacker'] = '553-1337' <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Standard ML</h3> 
       <div class="section-body"> 
        <p> The SML'97 standard of the <a href="Standard ML">Standard ML</a> programming language does not provide any associative containers. However, various implementations of Standard ML do provide associative containers. </p> 
        <p> The library of the popular <a href="Standard ML of New Jersey">Standard ML of New Jersey</a> implementation provides a signature (kind of like an &quot;interface&quot;), <code>ORD_MAP</code>, which defines a common interface for ordered functional (immutable) associative arrays. There are several general functors, <code>BinaryMapFn</code>, <code>ListMapFn</code>, <code>RedBlackMapFn</code>, and <code>SplayMapFn</code>, that allow you to create the corresponding type of ordered map (the types are a <a href="self-balancing binary search tree">self-balancing binary search tree</a>, sorted <a href="association list">association list</a>, <a href="red-black tree">red-black tree</a>, and <a href="splay tree">splay tree</a>, respectively) using a user-provided structure to describe the key type and comparator. The functor returns a structure that follows the <code>ORD_MAP</code> interface. In addition, there are two pre-defined modules for associative arrays with integer keys: <code>IntBinaryMap</code> and <code>IntListMap</code>. </p> 
        <p> <span class="unknown-node">&lt;pre&gt;...&lt;/pre&gt;</span> </p> 
        <p> SML/NJ also provides a polymorphic hash table: </p> 
        <p> <span class="unknown-node">&lt;pre&gt;...&lt;/pre&gt;</span> </p> 
        <p> Monomorphic hash tables are also supported using the <code>HashTableFn</code> functor. </p> 
        <p> Another Standard ML implementation, <a href="Moscow ML">Moscow ML</a>, also provides some associative containers. First, it provides polymorphic hash tables in the <code>Polyhash</code> structure. Also, some functional maps from the SML/NJ library above are available as <code>Binarymap</code>, <code>Splaymap</code>, and <code>Intmap</code> structures. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Tcl</h3> 
       <div class="section-body"> 
        <p> In <a href="Tcl">Tcl</a> every array is an associative array. As of Tcl 8.5, there is also the <b>dict</b> command that operates on dictionary <i>values</i>; arrays are always <i>variables</i>. </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Tcl&quot;&gt;</span> set &quot;phonebook(Sally Smart)&quot; 555-9999 set john &quot;John Doe&quot; set phonebook($john) 555-1212 set &quot;phonebook(J. Random Hacker)&quot; 553-1337 <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> The first argument of the <code>set</code> command has to be enclosed by double quotes when it contains an explicit space (even if the space is enclosed in an array parenthesis), because space is used to separate arguments in Tcl. This is not an issue with spaces inserted by substitution however, as the space in <tt>$john</tt>. </p> 
        <p> Alternatively, several array elements can be set in a single command by providing their mappings as a dictionary (keys braced because they contain whitespace): </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Tcl&quot;&gt;</span> array set phonebook { {Sally Smart} 555-9999 {John Doe} 555-1212 {J. Random Hacker} 553-1337 } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> To access one array entry and put it on standard output </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Tcl&quot;&gt;</span> puts &quot;$phonebook(Sally Smart)&quot; <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> The result is here </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Text&quot;&gt;</span> 555-9999 <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> To retrieve the entire array as a dictionary: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Tcl&quot;&gt;</span> array get phonebook <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> The result can be (order of keys is unspecified): </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Tcl&quot;&gt;</span> {Sally Smart} 555-9999 {J. Random Hacker} 553-1337 {John Doe} 555-1212 <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Visual Basic</h3> 
       <div class="section-body"> 
        <p> There is no standard implementation common to all dialects. <a href="Visual Basic">Visual Basic</a> can use the Dictionary class from the <a href="Windows Scripting Host">Microsoft Scripting Runtime</a> (which is shipped with Visual Basic 6): </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;VB&quot;&gt;</span> ' Requires a reference to SCRRUN.DLL in Project Properties Dim phoneBook As New Dictionary phoneBook.Add &quot;Sally Smart&quot;, &quot;555-9999&quot; phoneBook.Item(&quot;John Doe&quot;) = &quot;555-1212&quot; phoneBook(&quot;J. Random Hacker&quot;) = &quot;553-1337&quot; For Each name In phoneBook MsgBox name &amp; &quot; = &quot; &amp; phoneBook(name) Next <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> <a href="Visual Basic .NET">Visual Basic .NET</a> relies on the collection classes provided by <a href=".NET Framework">.NET Framework</a>: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;VBNet&quot;&gt;</span> Dim phoneBook As New System.Collections.Generic.Dictionary(Of String, String) phoneBook(&quot;Sally Smart&quot;) = &quot;555-9999&quot; phoneBook(&quot;John Doe&quot;) = &quot;555-1212&quot; phoneBook(&quot;J. Random Hacker&quot;) = &quot;553-1337&quot; For Each entry As KeyValuePair(Of String, String) In phoneBook MessageBox.Show(entry.Key &amp; &quot; = &quot; &amp; entry.Value) Next <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>Windows PowerShell</h3> 
       <div class="section-body"> 
        <p> Unlike many other <a href="command line interpreter">command line interpreters</a>, <a href="Windows PowerShell">PowerShell</a> has built-in, language-level support for defining associative arrays. </p> 
        <p> For example: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;PowerShell&quot;&gt;</span> $phonebook = @{ </p> 
        <pre>       'Sally Smart' = '555-9999';
</pre> 
        <p> 'John Doe' = '555-1212'; 'J. Random Hacker' = '553-1337' } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Like in JavaScript, if the property name is a valid identifier, the quotes can be omitted, e.g.: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;PowerShell&quot;&gt;</span> $myOtherObject = @{ foo = 42; bar = $false } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Entries can be separated by either a semicolon or a newline, e.g.: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;Text&quot;&gt;</span> $myOtherObject = @{ foo = 42 </p> 
        <pre>                   bar = $false ;
                   zaz = 3
</pre> 
        <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Keys and values can be any <a href=".NET Framework">.NET</a> object type, e.g.: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;PowerShell&quot;&gt;</span> $now = [DateTime]::Now $tomorrow = $now.AddDays(1) $ProcessDeletionSchedule = @{ </p> 
        <pre>       (Get-Process notepad) = $now 
       (Get-Process calc) = $tomorrow
</pre> 
        <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> It is also possible to create an empty associative array and add single entries or even other associative arrays to it later on. </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;PowerShell&quot;&gt;</span> $phonebook = @{} $phonebook += @{ 'Sally Smart' = '555-9999' } $phonebook += @{ 'John Doe' = '555-1212'; 'J. Random Hacker' = '553-1337' } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> New entries can also be added by using the array index operator, the property operator or the <code>Add()</code> method of the underlying .NET object: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;PowerShell&quot;&gt;</span> $phonebook = @{} $phonebook['Sally Smart'] = '555-9999' $phonebook.'John Doe' = '555-1212' $phonebook.Add('J. Random Hacker', '553-1337') <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> To dereference assigned objects the array index operator, the property operator or the parameterized property <code>Item()</code> of the .NET object can be used: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;PowerShell&quot;&gt;</span> $phonebook['Sally Smart'] $phonebook.'John Doe' $phonebook.Item('J. Random Hacker') <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> You can loop through an associative array as follows: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;PowerShell&quot;&gt;</span> $phonebook.Keys | foreach { &quot;Number for {0}: {1}&quot; -f $_,$phonebook.$_ } <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> An entry can be removed using the <code>Remove()</code> method of the underlying .NET object: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;PowerShell&quot;&gt;</span> $phonebook.Remove('Sally Smart') <span class="unknown-node">&lt;/source&gt;</span> </p> 
        <p> Hash tables can be added, e.g.: </p> 
        <p> <span class="unknown-node">&lt;source lang=&quot;PowerShell&quot;&gt;</span> $hash1 = @{ a=1; b=2 } $hash2 = @{ c=3; d=4 } $hash3 = $hash1 + $hash2 <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
     </div> 
    </div> 
    <div class="section"> 
     <h2>Data serialization formats support</h2> 
     <div class="section-body"> 
      <p> <span class="unknown-node">{{Expand section|...}}</span> </p> 
      <p> Many data serialization formats also support associative arrays (see <a href="Comparison of data serialization formats#Syntax comparison of human-readable formats">this table</a>) </p> 
      <div class="section"> 
       <h3>JSON</h3> 
       <div class="section-body"> 
        <p> Keys can only be strings <span class="unknown-node">&lt;source lang=&quot;JavaScript&quot;&gt;</span> { </p> 
        <pre>   &quot;Sally Smart&quot;: &quot;555-9999&quot;,
   &quot;John Doe&quot;: &quot;555-1212&quot;,
   &quot;J. Random Hacker&quot;: &quot;555-1337&quot;
</pre> 
        <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3>YAML</h3> 
       <div class="section-body"> 
        <p> <span class="unknown-node">&lt;source lang=&quot;YAML&quot;&gt;</span> Sally Smart: 555-9999 John Doe: 555-1212 J. Random Hacker: 555-1337 <span class="unknown-node">&lt;/source&gt;</span> </p> 
       </div> 
      </div> 
     </div> 
    </div> 
    <div class="section"> 
     <h2>References</h2> 
     <div class="section-body"> 
      <p> <span class="unknown-node">{{Reflist|...}}</span> </p> 
      <p> <span class="unknown-node">{{DEFAULTSORT:Comparison Of Programming Languages (Mapping)}}</span> <a href="Category:Associative arrays">Category:Associative arrays</a> </p> 
     </div> 
    </div> 
   </div> 
  </div>    
 </body>
</html>