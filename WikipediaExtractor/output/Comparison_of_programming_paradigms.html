<!--?xml version="1.0" encoding="UTF-8" ?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <title>Comparison of programming paradigms</title> 
  <style type="text/css">
		<!--
			/**
			 * Copyright 2011 The Open Source Research Group,
			 *                University of Erlangen-N??rnberg
			 *
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */
			
			/******************************************************************************* 
			 * Default CSS styles for HtmlPrinters
			 ******************************************************************************/
			h1,h2,h3,h4,h5,h6 {
				background: none repeat scroll 0 0 transparent;
				border-bottom: 1px solid #AAAAAA;
				color: black;
				font-weight: normal;
				margin: 0;
				padding-bottom: 0.17em;
				width: auto;
				text-align: left;
			}
			
			h1,h2 {
				margin-bottom: 0.6em;
			}
			
			h3,h4,h5,h6 {
				border-bottom: medium none;
				font-weight: bold;
			}
			
			h3,h4,h5 {
				margin-bottom: 0.3em;
			}
			
			h1 {
				font-size: 188%;
			}
			
			h2 {
				font-size: 150%;
			}
			
			h3 {
				font-size: 132%;
			}
			
			p {
				line-height: 1.5em;
				margin: 0.4em 0 0.5em;
				/* DEBUG: */
				border: 1px solid silver;
				margin: 1px;
			}
			
			pre {
				padding: 1em;
				border: 1px dashed #2F6FAB;
				color: black;
				background-color: #F9F9F9;
				line-height: 1.1em;
				font-family: monospace, "Courier New";
			}
			
			.content {
				line-height: 1.5em;
				color: black;
				font-family: sans-serif;
			}
			
			.article-heading {
				font-size: 1.6em;
				line-height: 1.2em;
				margin-bottom: 0.1em;
				margin-top: 0;
				padding-bottom: 0;
				padding-top: 0;
			}
			
			.article-content {
				line-height: 1.5em;
				position: relative;
				width: 100%;
				font-size: 0.8em;
			}
			
			.section {
				padding-top: 0.5em;
				/* DEBUG: */
				border-left: 2px solid #FF6633;
				padding-top: 0;
				padding-left: 1em;
				margin-top: 1em;
				margin-bottom: 1em;
			}
			
			/******************************************************************************* 
			 * Images 
			 ******************************************************************************/
			div.thumb {
				background-color: transparent;
				border-color: white;
				border-style: solid;
				margin-bottom: 0.5em;
				max-width: 234px;
			}
			
			div.thumbinner {
				background-color: #F9F9F9;
				border: 1px solid #CCCCCC;
				font-size: 94%;
				overflow: hidden;
				padding: 3px !important;
				text-align: center;
			}
			
			img.thumbimage {
				border: 1px solid #CCCCCC;
				max-width: 220px;
				max-height: 225px;
			}
			
			img.plainimage {
				max-width: 220px;
				max-height: 225px;
			}
			
			div.thumbcaption {
				border: medium none;
				font-size: 94%;
				line-height: 1.4em;
				padding: 3px !important;
				text-align: left;
			}
			
			div.tright {
				border-width: 0.5em 0 0.8em 1.4em;
				clear: right;
				float: right;
			}
			
			div.tleft {
				border-width: 0.5em 1.4em 0.8em 0;
				clear: left;
				float: left;
				margin-right: 0.5em;
			}
			
			img.thumbborder {
				border: 1px solid #DDDDDD;
			}
			
			/******************************************************************************* 
			 * Misc 
			 ******************************************************************************/
			.illegal {
				color: #CC3300;
				font-weight: normal;
			}
			
			.redirect {
				color: #FFCC00;
				font-weight: normal;
			}
			
			.magic-word {
				color: #9900CC;
				font-weight: bold;
			}
			
			/******************************************************************************* 
			 * Tables 
			 ******************************************************************************/
			table {
				font-size: 100%;
				color: black;
				background-color: white;
			}
			
			fieldset table {
				background: none;
			}
			
			table.wikitable {
				background: none repeat scroll 0 0 #F9F9F9;
				border: 1px solid #AAAAAA;
				border-collapse: collapse;
				margin: 1em 1em 1em 0;
			}
			
			.wikitable th,.wikitable td {
				border: 1px solid #AAAAAA;
				padding: 0.2em;
			}
			
			.wikitable th {
				background: none repeat scroll 0 0 #F2F2F2;
				text-align: center;
			}
			
			.wikitable caption {
				font-weight: bold;
			}
			
			table.collapsed tr.collapsable {
				display: none;
			}
			
			/******************************************************************************* 
			 * Debug 
			 ******************************************************************************/
			.unknown-node {
				color: #FFBBBB;
				font-weight: normal;
			}
			/******************************************************************************* 
			 * End of file 
			 ******************************************************************************/
		-->
	</style> 
 </head> 
 <body> 
  <div class="content"> 
   <h1 class="article-heading">Comparison of programming paradigms</h1> 
   <div class="article-content"> 
    <p> <span class="unknown-node">{{refimprove|...}}</span> <span class="unknown-node">{{Programming paradigms}}</span> This article attempts to set out the various similarities and differences between the various <a href="programming paradigm">programming paradigms</a> as a summary in both graphical and tabular format with links to the separate discussions concerning these similarities and differences in extant Wikipedia articles. </p> 
    <div class="section"> 
     <h2> Main paradigm approaches </h2> 
     <div class="section-body"> 
      <p> <span class="unknown-node">{{Original research|...}}</span> The following are considered<span class="unknown-node">{{By whom|...}}</span> the main programming paradigms. There is inevitably some overlap in these paradigms but the main features or identifiable differences are summarized in the following table: </p> 
      <pre>
</pre> 
      <ul> 
       <li> <a href="Imperative programming">Imperative programming</a> ? defines <a href="computation">computation</a> as <a href="statement (programming)">statements</a> that change a program <a href="state (computer science)">state</a></li> 
       <li> <a href="Functional programming">Functional programming</a> ? treats computation as the evaluation of <a href="function (mathematics)">mathematical functions</a> and avoids <a href="program state">state</a> and <a href="immutable object">mutable</a> data</li> 
       <li> <a href="Procedural programming">Procedural programming</a>, <a href="structured programming">structured programming</a> ? specifies the steps the program must take to reach the desired state.</li> 
       <li> <a href="Event-driven programming">Event-driven programming</a> ? the <a href="program flow">flow of the program</a> is determined by <a href="event (computing)">events</a>, such as <a href="sensor">sensor</a> outputs or user actions (<a href="computer mouse">mouse</a> clicks, key presses) or <a href="message passing">messages</a> from other programs or <a href="thread (computer science)">threads</a>.</li> 
       <li> <a href="Object-oriented programming">Object-oriented programming</a> (OOP) ? organizes programs as <i><a href="object (computer science)">objects</a></i>: <a href="data structure">data structures</a> consisting of <a href="field (computer science)">datafields</a> and <a href="method (computer science)">methods</a> together with their interactions.</li> 
       <li> <a href="Declarative programming">Declarative programming</a> ? defines computation logic without defining its <a href="control flow">control flow</a>.</li> 
       <li> <a href="Automata-based programming">Automata-based programming</a> ? a program, or part, is treated as a model of a finite state machine or any other formal automata.</li> 
      </ul> 
      <p> None of the main programming paradigms have a precise, globally unanimous definition, let alone an official international standard. Nor is there any agreement on which paradigm constitutes the best approach to developing software. The subroutines that actually implement OOP methods might be ultimately coded in an imperative, functional or procedural style that might, or might not, directly alter <a href="state (computer science)">state</a> on behalf of the invoking program. </p> 
      <table class="wikitable sortable"> 
       <tbody>
        <tr> 
         <th> <p> <a href="programming paradigm">Paradigm</a> </p> </th> 
         <th> <p> Description </p> </th> 
         <th> <p> Main characteristics </p> </th> 
         <th> <p> Related paradigm(s) </p> </th> 
         <th> <p> Critics? </p> </th> 
         <th> <p> Examples </p> </th> 
        </tr> 
        <tr> 
         <th> <p> <a href="imperative programming">Imperative</a> </p> </th> 
         <td> <p> Computation as <a href="statement (programming)">statements</a> that <i>directly</i> change a program <a href="state (computer science)">state</a> (<a href="field (computer science)">datafields</a>) </p> </td> 
         <td> <p> Direct <a href="assignment (computer science)">assignments</a>, common <a href="data structure">data structures</a>, <a href="global variable">global variables</a> </p> </td> 
         <td> </td> 
         <td> <p> <a href="Edsger W. Dijkstra">Edsger W. Dijkstra</a>, <a href="Michael A. Jackson">Michael A. Jackson</a> </p> </td> 
         <td> <p> <a href="C (programming language)">C</a>, <a href="C++">C++</a>, <a href="Java (programming language)">Java</a>, <a href="PHP">PHP</a>, <a href="Python (programming language)">Python</a> </p> </td> 
        </tr> 
        <tr> 
         <th> <p> <a href="structured programming">Structured</a> </p> </th> 
         <td> <p> A style of <a href="imperative programming">imperative programming</a> with more logical program structure </p> </td> 
         <td> <p> <a href="Structogram">Structograms</a>, <a href="indent style">indentation</a>, either no, or limited use of, <a href="goto">goto</a> statements </p> </td> 
         <td> <p> Imperative </p> </td> 
         <td> </td> 
         <td> <p> <a href="C (programming language)">C</a>, <a href="C++">C++</a>, <a href="Java (programming language)">Java</a> </p> </td> 
        </tr> 
        <tr> 
         <th> <p> <a href="procedural programming">Procedural</a> </p> </th> 
         <td> <p> Derived from structured programming, based on the concept of <a href="modular programming">modular programming</a> or the <i>procedure call</i> </p> </td> 
         <td> <p> <a href="Local variable">Local variables</a>, sequence, selection, <a href="iteration">iteration</a>, and <a href="modular programming">modularization</a> </p> </td> 
         <td> <p> Structured, imperative </p> </td> 
         <td> </td> 
         <td> <p> <a href="C (programming language)">C</a>, <a href="C++">C++</a>, <a href="Lisp (programming language)">Lisp</a>, <a href="PHP">PHP</a>, <a href="Python (programming language)">Python</a> </p> </td> 
        </tr> 
        <tr> 
         <th> <p> <a href="functional programming">Functional</a> </p> </th> 
         <td> <p> Treats <a href="computation">computation</a> as the evaluation of <a href="function (mathematics)">mathematical functions</a> avoiding <a href="program state">state</a> and <a href="immutable object">mutable</a> data </p> </td> 
         <td> <p> <a href="Lambda calculus">Lambda calculus</a>, <a href="compositionality">compositionality</a>, <a href="formula">formula</a>, <a href="recursion (computer science)">recursion</a>, <a href="referential transparency (computer science)">referential transparency</a>, no <a href="side effect (computer science)">side effects</a> </p> </td> 
         <td> </td> 
         <td> </td> 
         <td> <p> <a href="Erlang (programming language)">Erlang</a>, <a href="Haskell (programming language)">Haskell</a>, <a href="Lisp (programming language)">Lisp</a>, <a href="Clojure">Clojure</a>, <a href="Scala (programming language)">Scala</a> </p> </td> 
        </tr> 
        <tr> 
         <th> <p> <a href="event-driven programming">Event-driven</a> including <a href="time-driven programming">time driven</a> </p> </th> 
         <td> <p> <a href="Program flow">Program flow</a> is determined mainly by <a href="event (computing)">events</a>, such as <a href="mouse click">mouse clicks</a> or interrupts including timer </p> </td> 
         <td> <p> <a href="Main loop">Main loop</a>, event handlers, <a href="asynchronous programming">asynchronous processes</a> </p> </td> 
         <td> <p> Procedural, <a href="dataflow">dataflow</a> </p> </td> 
         <td> </td> 
         <td> </td> 
        </tr> 
        <tr> 
         <th> <p> <a href="object-oriented programming">Object-oriented</a> </p> </th> 
         <td> <p> Treats <a href="Field (computer science)">datafields</a> as <i>objects</i> manipulated through pre-defined <a href="method (computer science)">methods</a> only </p> </td> 
         <td> <p> <a href="object (computer science)">Objects</a>, methods, <a href="message passing">message passing</a>, <a href="information hiding">information hiding</a>, <a href="data abstraction">data abstraction</a>, <a href="encapsulation (computer science)">encapsulation</a>, <a href="polymorphism in object-oriented programming">polymorphism</a>, <a href="inheritance (computer science)">inheritance</a>, <a href="serialization">serialization</a>-marshalling </p> </td> 
         <td> </td> 
         <td> <p> <a href="object-oriented programming#Criticism">See here</a> and<span class="unknown-node">&lt;ref .../&gt;</span><span class="unknown-node">&lt;ref .../&gt;</span> </p> </td> 
         <td> <p> <a href="C++">C++</a>, <a href="C sharp (programming language)">C#</a>, <a href="Java (programming language)">Java</a>, <a href="PHP">PHP</a>, <a href="Python (programming language)">Python</a>, <a href="Ruby (programming language)">Ruby</a> </p> </td> 
        </tr> 
        <tr> 
         <th> <p> <a href="declarative programming">Declarative</a> </p> </th> 
         <td> <p> Defines computation logic without defining its detailed <a href="control flow">control flow</a> </p> </td> 
         <td> <p> <a href="4GL">4GLs</a>, <a href="spreadsheet">spreadsheets</a>, <a href="report program generator">report program generators</a> </p> </td> 
         <td> </td> 
         <td> </td> 
         <td> <p> <a href="SQL">SQL</a>, <a href="regular expressions">regular expressions</a>, <a href="Cascading Style Sheets">CSS</a> </p> </td> 
        </tr> 
        <tr> 
         <th> <p> <a href="Automata-based programming">Automata-based programming</a> </p> </th> 
         <td> <p> Treats programs as a model of a <a href="finite state machine">finite state machine</a> or any other formal automata </p> </td> 
         <td> <p> <a href="enumeration">State enumeration</a>, <a href="control variable">control variable</a>, <a href="state (computer science)">state</a> changes, <a href="isomorphism">isomorphism</a>, <a href="state transition table">state transition table</a> </p> </td> 
         <td> <p> Imperative, event-driven </p> </td> 
         <td> </td> 
         <td> </td> 
        </tr> 
        <tr> 
        </tr> 
        <tr class="sortbottom"> 
         <th> <p> <a href="programming paradigm">Paradigm</a> </p> </th> 
         <th> <p> Description </p> </th> 
         <th> <p> Main characteristics </p> </th> 
         <th> <p> Related paradigm(s) </p> </th> 
         <th> <p> Critics? </p> </th> 
         <th> <p> Examples </p> </th> 
        </tr> 
       </tbody>
      </table> 
     </div> 
    </div> 
    <div class="section"> 
     <h2> Differences in terminology </h2> 
     <div class="section-body"> 
      <p> Despite multiple (types of) programming <a href="paradigm">paradigms</a> existing in parallel (with sometimes apparently conflicting definitions), many of the underlying <i><a href="essence">fundamental components</a></i> remain more or less the same (<a href="constant (programming)">constants</a>, <a href="variable (programming)">variables</a>, <a href="field (computer science)">datafields</a>, <a href="subroutine">subroutines</a>, calls etc.) and must somehow therefore inevitably be incorporated into each separate paradigm with equally similar attributes or functions. The table above is not intended as a guide to precise similarities, but more an index of where to look for more information - based on the different naming of these entities - within each paradigm. Non-standardized implementations of each paradigm in numerous <a href="programming language">programming languages</a> further complicate the overall picture, especially those languages that support <a href="multi-paradigm programming language">multiple paradigms</a>, each with its own <a href="jargon">jargon</a>. <span class="unknown-node">{{cquote2|...}}</span> </p> 
     </div> 
    </div> 
    <div class="section"> 
     <h2> Language support </h2> 
     <div class="section-body"> 
      <p> <span class="unknown-node">{{Main|...}}</span> <a href="Syntactic sugar">Syntactic sugar</a> is the <i>sweetening</i> of program functionality by introducing language features that facilitate particular usage, even if the end result could be achieved without them. One example of syntactic sugar may arguably be classes in <a href="C++">C++</a> (and in <a href="Java (programming language)">Java</a>, <a href="C Sharp (programming language)">C#</a>, etc.). The <a href="C (programming language)">C</a> language can support <a href="object-oriented programming">object-oriented programming</a> via its facilities of <a href="function pointer">function pointers</a>, type casting, and structures. However, languages such as C++ aim to make object-oriented programming more convenient by introducing syntax specific to this coding style. Moreover, the specialized syntax works to emphasize the object-oriented approach. Similarly, functions and looping syntax in C (and other procedural and structured programming languages) could be considered syntactic sugar. <a href="Assembly language">Assembly language</a> can support procedural or structured programming via its facilities for modifying register values and branching execution depending on program state. However, languages such as C introduced syntax specific to these coding styles to make procedural and structured programming more convenient. Features of the C# (C Sharp) programming language, such as properties and interfaces, similarly do not enable new functionality, but are designed to make good programming practices more prominent and natural. </p> 
      <p> Some programmers feel that these features are unimportant or even frivolous. For example, <a href="Alan Perlis">Alan Perlis</a> once quipped, in a reference to <a href="curly bracket programming language">bracket-delimited languages</a>, that &quot;syntactic sugar causes cancer of the <a href="semicolon">semicolon</a>&quot; (see <a href="Epigrams on Programming">Epigrams on Programming</a>). </p> 
      <p> An extension of this is the <a href="syntactic sugar#Syntactic saccharin">syntactic saccharin</a>, or gratuitous syntax that does not make programming easier.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
     </div> 
    </div> 
    <div class="section"> 
     <h2> Performance comparison </h2> 
     <div class="section-body"> 
      <p> Purely in terms of total <a href="instruction path length">instruction path length</a>, a program coded in an imperative style, without using any subroutines at all, would have the lowest count. However, the <a href="binary file">binary</a> size of such a program might be larger than the same program coded using subroutines (as in functional and procedural programming) and would reference more <a href="locality of reference">&quot;non-local&quot;</a> <i>physical</i> instructions that may increase <a href="cache misses">cache misses</a> and increase instruction fetch <a href="computational overhead">overhead</a> in modern processors. </p> 
      <p> The paradigms that use subroutines extensively (including functional, procedural and object-oriented) and do not also use significant <a href="inlining">inlining</a> (via <a href="compiler optimization">compiler optimizations</a>) will, consequently, use a greater percentage of total resources on the subroutine linkages themselves. Object oriented programs that do not deliberately alter <a href="program state">program state</a> directly, instead using <a href="mutator method">mutator methods</a> (or &quot;setters&quot;) to encapsulate these state changes, will, as a direct consequence, have a greater overhead. This is due to the fact that <a href="message passing">message passing</a> is essentially a subroutine call, but with three more additional overheads: <a href="dynamic memory allocation">dynamic memory allocation</a>, parameter copying and <a href="dynamic dispatch">dynamic dispatch</a>. Obtaining memory from the <a href="dynamic memory allocation">heap</a> and copying parameters for message passing may involve significant resources that far exceed those required for the state change itself. Accessors (or &quot;getters&quot;) that merely return the values of private member variables also depend upon similar message passing subroutines, instead of using a more direct assignment (or comparison), adding to total path length. </p> 
      <div class="section"> 
       <h3> Managed code </h3> 
       <div class="section-body"> 
        <p> For programs executing in a <i><a href="managed code">managed code</a></i> environment, such as the <a href=".NET Framework">.NET Framework</a>, many issues affect performance that are significantly affected by the programming language paradigm and various language features used.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Pseudocode examples comparing various paradigms </h3> 
       <div class="section-body"> 
        <p> A pseudocode comparison of imperative, procedural, and object oriented approaches used to calculate the area of a circle (<span class="unknown-node">&lt;math&gt;...&lt;/math&gt;</span>), assuming no subroutine <a href="inlining">inlining</a>, no <a href="macro (computer science)">macro</a> preprocessors, register arithmetic and weighting each instruction 'step' as just 1 instruction - as a crude measure of <a href="instruction path length">instruction path length</a> - is presented below. The instruction step that is conceptually performing the actual state change is highlighted in bold typeface in each case. Note that the actual arithmetic operations used to compute the area of the circle are the same in all three paradigms, with the difference being that the procedural and object-oriented paradigms wrap those operations in a subroutine call that makes the computation general and reusable. The same effect could be achieved in a <a href="purely imperative">purely imperative</a> program using a macro preprocessor at just the cost of increased program size (only at each macro invocation site) without a corresponding <a href="pro rata">pro rata</a> runtime cost (proportional to <i>n</i> invocations - that may be situated within an <a href="inner loop">inner loop</a> for instance). Conversely, subroutine inlining by a compiler could reduce procedural programs to something similar in size to the purely imperative code. However, for object-oriented programs, even with inlining, messages still have to be built (from copies of the arguments) for processing by the object-oriented methods. The overhead of calls, virtual or otherwise, is not dominated by the <a href="control flow">control flow</a> alteration itself - but by the surrounding <a href="calling convention">calling convention</a> costs, like <a href="function prologue">prologue and epilogue</a> code, stack setup and <a href="parameter (computer programming)#Parameters and arguments">argument</a> passing<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> (see here<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> for more realistic instruction path length, stack and other costs associated with calls on an <a href="x86">x86</a> platform). See also here<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> for a slide presentation by <a href="Eric S. Roberts">Eric S. Roberts</a> (&quot;The Allocation of Memory to Variables&quot;, chapter 7)<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> - illustrating the use of stack and heap memory usage when summing three <a href="rational number">rational numbers</a> in the <a href="Java (programming language)">Java</a> object-oriented language. </p> 
        <table class="wikitable" border="1" cellpadding="1"> 
         <tbody>
          <tr>
           <th> <p> Imperative </p> </th> 
           <th> <p> Procedural </p> </th> 
           <th> <p> Object-oriented </p> </th> 
          </tr>
          <tr> 
           <td> <p> <code> </code> </p> <pre><code> load r;                      1</code>
<code> r2 = r * r;                  2</code>
<code> <b>result = r2 * &quot;3.142&quot;;</b>       3</code>
<code>. </code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.... storage .............</code>
<code>result variable</code>
<code>constant &quot;3.142&quot;</code>
</pre> <code> </code> <p> </p> </td> 
           <td> <p> <code> </code> </p> <pre><code>area proc(r2,res):</code>
<code>   push stack                                 5</code>
<code>   load r2;                                   6</code>
<code>   r3 = r2 * r2;                              7</code>
<code>   <b>res = r3 * &quot;3.142&quot;;</b>                        8</code>
<code>   pop stack                                  9</code>
<code>   return;                                   10</code>
<code>...............................................</code>
<code>main proc:</code>
<code>   load r;                                    1</code>
<code>   call area(r,result);</code>
<code>    +load p = address of parameter list;      2</code>
<code>    +load v = address of subroutine 'area';   3</code>
<code>    +goto v with return;                      4</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.</code>
<code>.... storage .............</code>
<code>result variable</code>
<code>constant &quot;3.142&quot; </code>
<code>parameter list variable</code>
<code>function pointer (==&gt;area)</code>
<code>stack storage</code>
</pre> <code> </code> <p> </p> </td> 
           <td> <p> <code> </code> </p> <pre><code>circle.area method(r2):</code>
<code>   push stack                                 7</code>
<code>   load r2;                                   8</code>
<code>   r3 = r2 * r2;                              9</code>
<code>   res = r3 * &quot;3.142&quot;;                       10</code>
<code>   pop stack                                 11</code>
<code>   <b>return(res);</b>                           12,13</code>
<code>...............................................</code>
<code>main proc:</code>
<code>   load r;                                    1</code>
<code>   result = circle.area(r); </code>
<code>      +allocate heap storage;                 2<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span>                  </code>
<code>      +copy r to message;                     3</code>
<code>      +load p = address of message;           4</code>
<code>      +load v = addr. of method 'circle.area' 5</code>
<code>      +goto v with return;                    6</code>
<code>.</code>
<code>.</code>
<code>.... storage .............</code>
<code>result variable (assumed pre-allocated)</code>
<code>immutable variable &quot;3.142&quot; (final)</code>
<code>(heap) message variable for circle method call</code>
<code>vtable(==&gt;area)</code>
<code>stack storage</code>
</pre> <code> </code> <p> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <p> <span class="unknown-node">&lt;references group=&quot;See&quot; /&gt;</span> The advantages of procedural abstraction and object-oriented-style polymorphism are not well illustrated by a small example like the one above. This example is designed principally to illustrate some intrinsic performance differences, not abstraction or code re-use. </p> 
        <div class="section"> 
         <h4> Subroutine, method call overhead </h4> 
         <div class="section-body"> 
          <p> The presence of a (called) subroutine in a program contributes nothing extra to the functionality of the program regardless of paradigm, but may contribute greatly to the structuring and generality of the program, making it much easier to write, modify, and extend.<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> The extent to which different paradigms utilize subroutines (and their consequent memory requirements) influences the overall performance of the complete algorithm, although as <a href="Guy Steele">Guy Steele</a> pointed out in a 1977 paper, a well-designed programming language implementation <i>can</i> have very low overheads for procedural abstraction (but laments, in most implementations, that they seldom achieve this in practice - being &quot;rather thoughtless or careless in this regard&quot;). In the same paper, Steele also makes a considered case for <a href="automata-based programming">automata-based programming</a> (utilizing procedure calls with <a href="tail recursion">tail recursion</a>) and concludes that &quot;we should have a healthy respect for procedure calls&quot; (because they are powerful) but suggested &quot;use them sparingly&quot;<span class="unknown-node">&lt;ref .../&gt;</span> </p> 
          <pre>
</pre> 
          <p> In terms of the frequency of subroutine calls: </p> 
          <ul> 
           <li> for procedural programming, the <a href="granularity#Data granularity">granularity</a> of the code is largely determined by the number of discrete procedures or <a href="modular programming">modules</a>.</li> 
           <li> for functional programming, frequent calls to <a href="library (computing)">library</a> subroutines are commonplace<span class="unknown-node">{{Citation needed|...}}</span> (but may be frequently inlined by the optimizing compiler)</li> 
           <li> for object-oriented programming, the number of method calls invoked is also partly determined by the granularity of the data structures and may therefore include many <i>read-only</i> accesses to low level objects that are encapsulated (and therefore accessible in no other, more direct, way). Since increased granularity is a prerequisite for greater <a href="code reuse">code reuse</a>, the tendency is towards fine-grained data structures, and a corresponding increase in the number of discrete objects (and their methods) and, consequently, subroutine calls. The creation of <i><a href="god object">god objects</a></i> is actively discouraged. <a href="constructor (object-oriented programming)">Constructors</a> also add to the count as they are also subroutine calls (unless they are inlined). Performance problems caused by excessive granularity may not become apparent until <a href="scalability">scalability</a> becomes an issue.</li> 
           <li> for other paradigms, where a mixture of the above paradigms may be employed, subroutine usage is less predictable.</li> 
          </ul> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Allocation of dynamic memory for message and object storage </h4> 
         <div class="section-body"> 
          <p> Uniquely, the object-oriented paradigm involves dynamic allocation of memory from <a href="dynamic memory allocation">heap storage</a> for both object creation and message passing. A 1994 benchmark - &quot;Memory Allocation Costs in Large C and C++ Programs&quot; conducted by <a href="Digital Equipment Corporation">Digital Equipment Corporation</a> on a variety of software, using an instruction-level profiling tool, measured how many instructions were required per dynamic storage allocation. The results showed that the lowest absolute number of instructions executed averaged around 50 but others reached as high as 611.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> See also &quot;Heap:Pleasures and pains&quot; by Murali R. Krishnan<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> that states &quot;Heap implementations tend to stay general for all platforms, and hence have heavy overhead&quot;. The 1996 IBM paper &quot;Scalability of Dynamic Storage Allocation Algorithms&quot; by Arun Iyengar of IBM <span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> demonstrates various dynamic storage algorithms and their respective instruction counts. Even the recommended MFLF I algorithm (H.S. Stone, RC 9674) shows instruction counts in a range between 200 and 400. The above pseudocode example does not include a realistic estimate of this memory allocation pathlength or the memory prefix overheads involved and the subsequent associated garbage collection overheads. Suggesting strongly that heap allocation is a non-trivial task, one <a href="open source">open source</a> microallocator, by game developer <a href="John W. Ratcliff">John W. Ratcliff</a>, consists of nearly 1,000 lines of code.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Dynamically dispatched message calls v. direct procedure call overheads </h4> 
         <div class="section-body"> 
          <p> In their Abstract &quot;<i>Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis</i>&quot;,<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> Jeffrey Dean, David Grove, and Craig Chambers of the Department of Computer Science and Engineering, at the <a href="University of Washington">University of Washington</a>, claim that &quot;Heavy use of inheritance and dynamically-bound messages is likely to make code more extensible and reusable, but it also imposes a significant performance overhead, compared to an equivalent but non-extensible program written in a non-object-oriented manner. In some domains, such as structured graphics packages, the performance cost of the extra flexibility provided by using a heavily object-oriented style is acceptable. However, in other domains, such as basic data structure libraries, numerical computing packages, rendering libraries, and trace-driven simulation frameworks, the cost of message passing can be too great, forcing the programmer to avoid object-oriented programming in the ?hot spots? of their application.&quot; </p> 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Serialization of objects </h3> 
       <div class="section-body"> 
        <p> <span class="unknown-node">{{Main|...}}</span> <a href="Serialization">Serialization</a> imposes quite considerable overheads when passing <a href="object (computer science)">objects</a> from one system to another, especially when the transfer is in human-readable formats such as <a href="XML">XML</a> and <a href="JSON">JSON</a>. This contrasts with compact binary formats for non object-oriented data. Both encoding and decoding of the objects data value and its attributes are involved in the serialization process (that also includes awareness of complex issues such as inheritance, encapsulation and data hiding). </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Parallel computing </h3> 
       <div class="section-body"> 
        <p> <span class="unknown-node">{{Main|...}}</span> <a href="Carnegie-Mellon University">Carnegie-Mellon University</a> Professor <a href="Robert Harper (computer scientist)">Robert Harper</a> in March 2011 wrote: &quot;This semester Dan Licata and I are co-teaching a new course on <a href="functional programming">functional programming</a> for first-year prospective CS majors... Object-oriented programming is eliminated entirely from the introductory curriculum, because it is both anti-modular and anti-parallel by its very nature, and hence unsuitable for a modern CS curriculum. A proposed new course on object-oriented design methodology will be offered at the sophomore level for those students who wish to study this topic.&quot;<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
       </div> 
      </div> 
     </div> 
    </div> 
    <div class="section"> 
     <h2> See also </h2> 
     <div class="section-body"> 
      <ul> 
       <li> <a href="Comparison of programming languages">Comparison of programming languages</a></li> 
       <li> <a href="Comparison of programming languages (basic instructions)">Comparison of programming languages (basic instructions)</a></li> 
       <li> <a href="granularity#Computing">Granularity</a></li> 
       <li> <a href="Message passing">Message passing</a></li> 
       <li> <a href="Subroutine">Subroutine</a></li> 
      </ul> 
     </div> 
    </div> 
    <div class="section"> 
     <h2> References </h2> 
     <div class="section-body"> 
      <p> <span class="unknown-node">{{Reflist|...}}</span> </p> 
     </div> 
    </div> 
    <div class="section"> 
     <h2> Further reading </h2> 
     <div class="section-body"> 
      <ul> 
       <li> <a href="http://g.oswego.edu/dl/html/malloc.html">&quot;A Memory Allocator&quot;</a> by Doug Lea</li> 
       <li> <a href="http://www.sqa.org.uk/e-learning/LinkedDS01CD/page_01.htm">&quot;Dynamic Memory Allocation and Linked Data Structures&quot;</a> by (<a href="Scottish Qualifications Authority">Scottish Qualifications Authority</a>)</li> 
       <li> <a href="http://www.flounder.com/inside_storage_allocation.htm">&quot;Inside A Storage Allocator&quot;</a> by Dr. Newcomer Ph.D</li> 
      </ul> 
     </div> 
    </div> 
    <div class="section"> 
     <h2> External links </h2> 
     <div class="section-body"> 
      <ul> 
       <li> <a href="http://users.ecs.soton.ac.uk/mrd/research/prog.html">Comparing Programming Paradigms</a> by Dr Rachel Harrison and Mr Lins Samaraweera</li> 
       <li> <a href="http://eprints.ecs.soton.ac.uk/597/">Comparing Programming Paradigms: an Evaluation of Functional and Object-Oriented Programs</a> by Harrison, R., Samaraweera, L. G., Dobie, M. R. and Lewis, P. H. (1996) pp.&nbsp;247?254. ISSN 0268-6961</li> 
       <li> <a href="http://www.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng101.pdf">&quot;The principal programming paradigms&quot;</a> By Peter Van Roy</li> 
       <li> <a href="http://www.info.ucl.ac.be/~pvr/book.html">&quot;Concepts, Techniques, and Models of Computer Programming&quot; </a>(2004) by Peter Van Roy &amp; Seif Haridi, ISBN 0-262-22069-5</li> 
       <li> <a href="http://hbfs.wordpress.com/2008/12/30/the-true-cost-of-calls/">The True Cost of Calls</a>- from &quot;Harder, Better, Faster, Stronger&quot; blog by computer scientist <a href="http://www.stevenpigeon.org/Publications/">Steven Pigeon</a></li> 
      </ul> 
      <p> <span class="unknown-node">{{DEFAULTSORT:Comparison of programming paradigms}}</span> <a href="Category:Programming paradigms"> Comparison</a> </p> 
     </div> 
    </div> 
   </div> 
  </div>    
 </body>
</html>