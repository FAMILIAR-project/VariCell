<!--?xml version="1.0" encoding="UTF-8" ?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <title>Comparison of C Sharp and Java</title> 
  <style type="text/css">
		<!--
			/**
			 * Copyright 2011 The Open Source Research Group,
			 *                University of Erlangen-N??rnberg
			 *
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */
			
			/******************************************************************************* 
			 * Default CSS styles for HtmlPrinters
			 ******************************************************************************/
			h1,h2,h3,h4,h5,h6 {
				background: none repeat scroll 0 0 transparent;
				border-bottom: 1px solid #AAAAAA;
				color: black;
				font-weight: normal;
				margin: 0;
				padding-bottom: 0.17em;
				width: auto;
				text-align: left;
			}
			
			h1,h2 {
				margin-bottom: 0.6em;
			}
			
			h3,h4,h5,h6 {
				border-bottom: medium none;
				font-weight: bold;
			}
			
			h3,h4,h5 {
				margin-bottom: 0.3em;
			}
			
			h1 {
				font-size: 188%;
			}
			
			h2 {
				font-size: 150%;
			}
			
			h3 {
				font-size: 132%;
			}
			
			p {
				line-height: 1.5em;
				margin: 0.4em 0 0.5em;
				/* DEBUG: */
				border: 1px solid silver;
				margin: 1px;
			}
			
			pre {
				padding: 1em;
				border: 1px dashed #2F6FAB;
				color: black;
				background-color: #F9F9F9;
				line-height: 1.1em;
				font-family: monospace, "Courier New";
			}
			
			.content {
				line-height: 1.5em;
				color: black;
				font-family: sans-serif;
			}
			
			.article-heading {
				font-size: 1.6em;
				line-height: 1.2em;
				margin-bottom: 0.1em;
				margin-top: 0;
				padding-bottom: 0;
				padding-top: 0;
			}
			
			.article-content {
				line-height: 1.5em;
				position: relative;
				width: 100%;
				font-size: 0.8em;
			}
			
			.section {
				padding-top: 0.5em;
				/* DEBUG: */
				border-left: 2px solid #FF6633;
				padding-top: 0;
				padding-left: 1em;
				margin-top: 1em;
				margin-bottom: 1em;
			}
			
			/******************************************************************************* 
			 * Images 
			 ******************************************************************************/
			div.thumb {
				background-color: transparent;
				border-color: white;
				border-style: solid;
				margin-bottom: 0.5em;
				max-width: 234px;
			}
			
			div.thumbinner {
				background-color: #F9F9F9;
				border: 1px solid #CCCCCC;
				font-size: 94%;
				overflow: hidden;
				padding: 3px !important;
				text-align: center;
			}
			
			img.thumbimage {
				border: 1px solid #CCCCCC;
				max-width: 220px;
				max-height: 225px;
			}
			
			img.plainimage {
				max-width: 220px;
				max-height: 225px;
			}
			
			div.thumbcaption {
				border: medium none;
				font-size: 94%;
				line-height: 1.4em;
				padding: 3px !important;
				text-align: left;
			}
			
			div.tright {
				border-width: 0.5em 0 0.8em 1.4em;
				clear: right;
				float: right;
			}
			
			div.tleft {
				border-width: 0.5em 1.4em 0.8em 0;
				clear: left;
				float: left;
				margin-right: 0.5em;
			}
			
			img.thumbborder {
				border: 1px solid #DDDDDD;
			}
			
			/******************************************************************************* 
			 * Misc 
			 ******************************************************************************/
			.illegal {
				color: #CC3300;
				font-weight: normal;
			}
			
			.redirect {
				color: #FFCC00;
				font-weight: normal;
			}
			
			.magic-word {
				color: #9900CC;
				font-weight: bold;
			}
			
			/******************************************************************************* 
			 * Tables 
			 ******************************************************************************/
			table {
				font-size: 100%;
				color: black;
				background-color: white;
			}
			
			fieldset table {
				background: none;
			}
			
			table.wikitable {
				background: none repeat scroll 0 0 #F9F9F9;
				border: 1px solid #AAAAAA;
				border-collapse: collapse;
				margin: 1em 1em 1em 0;
			}
			
			.wikitable th,.wikitable td {
				border: 1px solid #AAAAAA;
				padding: 0.2em;
			}
			
			.wikitable th {
				background: none repeat scroll 0 0 #F2F2F2;
				text-align: center;
			}
			
			.wikitable caption {
				font-weight: bold;
			}
			
			table.collapsed tr.collapsable {
				display: none;
			}
			
			/******************************************************************************* 
			 * Debug 
			 ******************************************************************************/
			.unknown-node {
				color: #FFBBBB;
				font-weight: normal;
			}
			/******************************************************************************* 
			 * End of file 
			 ******************************************************************************/
		-->
	</style> 
 </head> 
 <body> 
  <div class="content"> 
   <h1 class="article-heading">Comparison of C Sharp and Java</h1> 
   <div class="article-content"> 
    <p> <span class="unknown-node">{{Multiple issues |...}}</span> <span class="unknown-node">{{Correct title |...}}</span> <span class="unknown-node">{{ProgLangCompare}}</span> </p> 
    <p> This article compares <a href="Microsoft">Microsoft's</a> <b><a href="C Sharp (programming language)">C#</a></b> programming language with <a href="Oracle Corporation">Oracle's</a> (formerly <a href="Sun Microsystems">Sun's</a>) <b><a href="Java (programming language)">Java</a></b> programming language. While the focus of this article is mainly the <a href="programming language">programming languages</a> and their features, such a comparison will necessarily also consider some <a href="Computing platform">platform</a> features and some <a href="Library (computing)">library</a> features. For a more detailed comparison of the platforms, please see <a href="Comparison of the Java and .NET platforms">Comparison of the Java and .NET platforms</a>. </p> 
    <p> The comparison focuses on areas where the languages differ. In fact the two languages and their platforms are more alike than they are different: Both are (primarily) statically, <a href="Strong typing">strongly</a>, and mostly <a href="manifest typing">manifestly</a> <a href="Type system">typed</a>, both are <a href="Class (computer science)">class-based</a> <a href="Object-oriented programming">object-oriented</a>, both are designed with semi-<a href="Interpreter (computing)">interpretation</a> or <a href="Just-in-time compilation">runtime compilation</a> in mind, both use <a href="garbage collection (computer science)">garbage-collection</a>, and both are &quot;<a href="Curly bracket programming language">curly brace languages</a>&quot; like <a href="C (programming language)">C</a> and <a href="C++">C++</a>. Common ancestry is also evident in their common terminology and often very similar <a href="Syntax (programming languages)">syntax</a> features. </p> 
    <div class="section"> 
     <h2> Language and features </h2> 
     <div class="section-body"> 
      <p> This section provides a comparison of the languages in terms of features they may or may not offer, or, put differently, properties they may or may not have. <i>The absence of a feature should not automatically be regarded as a disadvantage for the given language</i>. Sometimes features may be excluded because the language designers view them as specifically detrimental: in other cases, the designers may have viewed the feature as something that would be nice to have but not worth the added language complexity. </p> 
      <div class="section"> 
       <h3> Data types </h3> 
       <div class="section-body"> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> <a href="#Data types">Data types</a> </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> Single-root (unified) type system </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Signedness">Signed integers</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span>; 8, 16, 32, 64 bits </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span>; 8, 16, 32, 64 bits </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Unsigned integers">Unsigned integers</a> </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span>; 8, 16, 32, 64 bits </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Primitive data type#Characters and strings">Character</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Date/time </td> 
           <td> <span class="unknown-node">{{yes}}</span>; reference type </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span>; value type </p> </td> 
          </tr> 
          <tr> 
           <td> IEEE 754 <a href="binary32">binary32</a> floating point number </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> IEEE 754 <a href="binary64">binary64</a> floating point number </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> High precision decimal number </td> 
           <td> <span class="unknown-node">{{no}}</span>;but see <i>Arbitrary size decimals</i> below </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Boolean type">Boolean type</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Primitive data type#Characters and strings">Strings</a> </td> 
           <td> <span class="unknown-node">{{yes|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="#Advanced numeric types">Arbitrary size integers</a> </td> 
           <td> <span class="unknown-node">{{yes|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="#Advanced numeric types">Arbitrary size decimals</a> </td> 
           <td> <span class="unknown-node">{{yes|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{no}}</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="#Advanced numeric types">Complex numbers</a> </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="#Reference types">Reference types</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="#Arrays and collections">Arrays</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="#Value types">Value types</a> </td> 
           <td> <span class="unknown-node">{{no}}</span>; only primitive types </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="#Enumerations">Enumerated types</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span>; reference type </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span>; scalar </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="#Lifted (nullable) types">Lifted (nullable) types</a> </td> 
           <td> <span class="unknown-node">{{no}}</span>; but wrapper types </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Tuples">Tuples</a> </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="#Pointers">Pointers</a> </td> 
           <td> <span class="unknown-node">{{no}}</span><span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <div class="section"> 
         <h4> Unified type system </h4> 
         <div class="section-body"> 
          <p> The languages use very similar type systems. Both languages are statically typed with class-based object orientation. In Java the <a href="primitive types">primitive types</a> are special in that they are not <a href="object-oriented">object-oriented</a> and they could not have been defined using the language itself. They also do not share a common ancestor with reference types. The Java <a href="reference type">reference types</a> all derive from a common root type. C# has a unified <a href="type system">type system</a> in which all types (besides unsafe pointers<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span>) ultimately derive from a common root type. Consequently, all types implement the methods of this root type, and extension methods defined for the <code>object</code> type apply to all types, even primitive <code>int</code> literals and <a href="Delegate (CLI)">delegates</a>. Note, that unlike Java, this allows C# to support objects with encapsulation that are not reference types. </p> 
          <p> In Java compound types are synonymous with reference types; methods cannot be defined for a type unless it is also a <i>class</i> reference type. In C# the concepts of encapsulation and methods have been decoupled from the reference requirement so that a type can support methods and encapsulation without being a reference type. Only reference types support virtual methods and specialization, however. </p> 
          <p> Both languages support a number of built-in types that are copied and passed by value rather than by reference. Java calls these types <a href="primitive type">primitive types</a>, while they are called <i>simple types</i> in C#. The simple/primitive types typically have native support from the underlying processor architecture. </p> 
          <p> The C# primitive/simple types implement a number of interfaces and consequently offer a number of methods directly on instances of the types - even on the literals. The C# type names are also merely <i>aliases</i> for <a href="Common Language Runtime">Common Language Runtime</a> types. The C# <code>System.Int64</code> type is exactly the same type as the <code>long</code> type; the only difference is that the former is the canonical .NET name while the latter is a C# alias for it. </p> 
          <p> Java does not offer methods directly on the primitive types. Instead methods that operate on the primitive values are offered through companion <a href="Primitive wrapper class">wrapper classes</a>. A fixed set of such wrapper classes exist, each of which wraps one of the fixed set of primitive types. As an example, the Java <code>Long</code> type is a <a href="reference type">reference type</a> that wraps the primitive <code>long</code> type. They are <i>not</i> the same type, however. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Signed integers </h4> 
         <div class="section-body"> 
          <p> Both Java and C# supports <a href="signedness">signed</a> integers with bit widths of 8, 16, 32 and 64 bits. They use the same name/aliases for the types, except for the 8-bit integer which is called a <tt>byte</tt> in Java and a <tt>sbyte</tt> (signed byte) in C#. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Unsigned integers </h4> 
         <div class="section-body"> 
          <p> C# supports <a href="signedness">unsigned</a> in addition to the <a href="signedness">signed</a> integer types. The unsigned types are <tt>byte</tt>, <tt>ushort</tt>, <tt>uint</tt> and <tt>ulong</tt> for 8, 16, 32 and 64 bit widths, respectively. Unsigned arithmetic operating on the types are supported as well. For example, adding two unsigned integers (<tt>uint</tt>s) still yields a <tt>uint</tt> as a result; not a long or signed integer. </p> 
          <p> Java does not feature unsigned integer types. In particular, Java lacks a primitive type for an unsigned <a href="byte">byte</a>. Instead Java's <tt>byte</tt> type is sign extended which is a common source of bugs and confusion.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
          <p> Unsigned integers were deliberately left out of Java because <a href="James Gosling">James Gosling</a> believed that programmers would not understand how unsigned arithmetic works.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span><span class="unknown-node">&lt;ref .../&gt;</span> </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Characters </h4> 
         <div class="section-body"> 
          <p> Both languages feature a native <code>char</code> (character) datatype as a simple type. Although the <code>char</code> type can be used with bit-wise operators, this is actually accomplished by promoting the <code>char</code> value to an integer value before the operation. Thus, the result of a bitwise operation is a numeric type, not a character, in both languages. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Date/times </h4> 
         <div class="section-body"> 
          <p> <span class="unknown-node">{{empty section|...}}</span> </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> 32 and 64 bits floating point numbers </h4> 
         <div class="section-body"> 
          <p> <span class="unknown-node">{{empty section|...}}</span> </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> High-precision decimal numbers </h4> 
         <div class="section-body"> 
          <p> C# has a type and literal notation for high-precision (28 decimal digits) decimal arithmetic which is appropriate for financial and monetary calculations.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span><span class="unknown-node">&lt;ref .../&gt;</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> Contrary to the <tt>float</tt> and <tt>double</tt> data types, decimal fractional numbers such as 0.1 can be represented exactly in the decimal representation. In the float and double representations, such numbers often have non-terminating binary expansions, making those representations more prone to round-off errors.<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> </p> 
          <p> While Java lacks such a built-in type, the Java library does feature an <i>arbitrary precision</i> decimal type. This is not considered a language type and it does not support the usual arithmetic operators; rather it is a reference type that must be manipulated using the type methods. See more about arbitrary size/precision numbers <a href="#Advanced numeric types">below</a>. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Advanced numeric types </h4> 
         <div class="section-body"> 
          <p> Both languages offer library-defined <a href="Arbitrary-precision arithmetic">arbitrary size integer</a> types. </p> 
          <p> Only Java offers a data type for <a href="Arbitrary-precision arithmetic">arbitrary precision decimal point</a> calculations and only C# offers a type for working with <a href="complex numbers">complex numbers</a>. </p> 
          <p> In both languages the number of operations that can be performed on the advanced numeric types are limited compared to the built-in <a href="IEEE 754">IEEE 754</a> floating point types. For instance, none of the arbitrary size types support <a href="square root">square root</a> or <a href="logarithms">logarithms</a>. </p> 
          <p> C# allows library defined types to be integrated with existing types and operators by using custom implicit/explicit conversions and operator overloading. See example <a href="#Integration of library defined types">#Integration of library defined types</a> </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Built-in compound data types </h4> 
         <div class="section-body"> 
          <p> Both languages treat <a href="String (computer science)">strings</a> as (<a href="immutable object">immutable</a>) objects of reference type. In both languages the type contains a number of methods to manipulate strings, parse, format etc. In both languages <a href="regular expression">regular expressions</a> are considered an external feature and are implemented in separate classes. </p> 
          <p> Both languages' libraries define classes for working with dates and calendars in different cultures. The Java <code>java.util.Date</code> is a mutable reference type, where the C# <code>System.DateTime</code> is a struct value type. C# additionally define a <code>TimeSpan</code> type for working with time periods. Both languages support date and time arithmetic according to different cultures. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Value types </h4> 
         <div class="section-body"> 
          <p> C# allows the programmer to create user-defined <a href="value type">value types</a>, using the <code>struct</code> keyword. Unlike classes and like the standard primitives, such value types are passed and assigned by value rather than by reference. They can also be part of an object (either as a field or <a href="Boxing (programming)">boxed</a>), or stored in an array without the memory indirection that normally exists for class types. </p> 
          <p> Because value types have no notion of a <i><code>null</code></i> value and can be used in arrays without initialization, they always come with an implicit default constructor that essentially fills the struct memory space with zeroes. The programmer can only define additional constructors with one or more arguments. Value types do not have <a href="virtual method table">virtual method tables</a>, and because of that (and the fixed memory footprint), they are implicitly sealed. However, value types <i>can</i> (and frequently do) implement interfaces. For example, the built-in integer types implement a number of interfaces. </p> 
          <p> Apart from the built-in primitive types, Java does not include the concept of value types. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Enumerations </h4> 
         <div class="section-body"> 
          <table class="wikitable"> 
           <tbody>
            <tr>
             <th> </th> 
             <th> <p> Java </p> </th> 
             <th> <p> C# </p> </th> 
            </tr>
            <tr> 
             <td> <p> Definition </p> </td> 
             <td> <p> In Java, both the enumeration type and (optionally) the individual enumeration values are Java classes. The only valid values are the ones listed in the enumeration. The enumeration type may declare or override members (such as a dedicated <code>toString()</code> method) that will be inherited by the individual enumerated values, and it can be extended by adding methods, fields or even interfaces can be implemented for it.<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> The individual enumerated values may in turn override members or even define new members only valid for that specific value. </p> </td> 
             <td> <p> <a href="Enumeration">Enumerations</a> in C# are implicitly derived from the <code>Enum</code> type that again is a value type derivative. The value set of a C# enumeration is defined by the <i>underlying type</i> that can be a signed or unsigned integer type of 8, 16, 32 or 64 bits. The enumeration definition defines names for the selected integer values and is <a href="syntactic sugar">syntactic sugar</a>.<span class="unknown-node">&lt;ref .../&gt;</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> By default the first name is assigned the value 0 (zero) and the following names are assigned in increments of 1. Any value of the underlying primitive type is a valid value of the enumeration type, though an explicit cast may be needed to assign it. </p> </td> 
            </tr> 
            <tr> 
             <td> <p> Combining </p> </td> 
             <td> <p> Java enumeration set and map collections provide functionality to combine multiple enumeration values to a combined value. These special collections allows compiler optimization to minimize the overhead incurred by using collections as the combination mechanism. </p> </td> 
             <td> <p> C# supports bit-mapped enumerations where an actual value may be a combination of enumerated values bitwise or'ed together. The formatting and parsing methods implicitly defined by the type will attempt to use these values. </p> </td> 
            </tr> 
           </tbody>
          </table> 
          <p> In both C# and Java, programmers can use enumerations in a <a href="switch statement">switch statement</a> without conversion to a string or primitive integer type. However, C# disallows fall-throughs unless the case statement does not contain any code, as they are a main cause for hard-to-find bugs.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> Fall-throughs must be explicitly declared using <a href="goto">goto</a><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Delegates / method references </h4> 
         <div class="section-body"> 
          <p> C# implements object-oriented method pointers in the form of <a href="Delegate (CLI)">delegates</a>. A delegate is a special type that can capture a <a href="Type safety">type-safe</a> reference to a method. This reference can then be stored in a delegate-type variable or passed to a method through a delegate parameter for later invocation. C# delegates support <a href="Covariance and contravariance (computer science)">covariance and contravariance</a>, and can hold a reference to any signature-compatible static method, instance method, anonymous method or <a href="lambda expression">lambda expression</a>. </p> 
          <p> Delegates should not be confused with closures and inline functions. The concepts are related because a reference to a closure/inline function must be captured in a delegate reference to be useful at all. But a delegate does not always reference an inline function; it can also reference existing static or instance methods. Delegates form the basis of C# <a href="#Events">events</a> but should not be confused with those either. </p> 
          <p> Delegates were deliberately left out of Java because they were considered unnecessary and detrimental to the language, and because of potential performance issues.<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> Instead, alternative mechanisms are used. The <a href="wrapper pattern">wrapper pattern</a>, which resembles the delegates of C# in that it allows the client to access one or more client-defined methods through a known interface, is one such mechanism.<span class="unknown-node">{{citation needed |...}}</span> Another is the use of <a href="Adapter pattern">adapter</a> objects using inner classes, which the designers of Java argued are a better solution than bound method references.<span class="unknown-node">&lt;ref .../&gt;</span> </p> 
          <p> See also example <a href="#C# delegates and equivalent Java constructs">#C# delegates and equivalent Java constructs</a> </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Lifted (nullable) types </h4> 
         <div class="section-body"> 
          <p> C# allows value/primitive/simple types to be &quot;lifted&quot; to allow the special <code>null</code> value in addition to the type's native values. A type is lifted by adding a <code>?</code> suffix to the type name. Conversions are implicitly defined to convert between values of the base and the lifted type. The lifted type can be compared against <code>null</code> or it can be tested for <code>HasValue</code>. Also, lifted operators are implicitly and automatically defined based on their non-lifted base, where ? with the exception of some boolean operators ? a null argument will propagate to the result. </p> 
          <p> Java does not support type lifting as a concept, but all of the built-in primitive types have corresponding wrapper types, which do support the <code>null</code> value by virtue of being reference types (classes).<br /> According to the Java spec, any attempt to dereference the <code>null</code> reference must result in an exception being thrown at run-time, specifically a <code>NullPointerException</code>. (It would not make sense to dereference it otherwise, because, by definition, it points to no object in memory.) This also applies when attempting to <a href="Auto-unboxing">unbox</a> a variable of a wrapper type, which evaluates to <code>null</code>: the program will throw an exception, because actually there is no object to be unboxed - and therefore no boxed value to take part in the subsequent computation. </p> 
          <p> The following example illustrates the different behavior. In C#, the lifted * operator propagates the <code>null</code> value of the operand; in Java, unboxing the null reference throws an exception. </p> 
          <p> Not all C# lifted operators have been defined to propagate <code>null</code> unconditionally, if one of the operands is <code>null</code>. Specifically, the <a href="boolean operators">boolean operators</a> have been lifted to support <a href="ternary logic">ternary logic</a> thus keeping impedance with <a href="SQL">SQL</a>. </p> 
          <p> The Java boolean operators do not support ternary logic, nor is it implemented in the base class library. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Late-bound (dynamic) type </h4> 
         <div class="section-body"> 
          <p> C# features a <a href="Name binding">late bound</a> dynamic type that supports no-reflection dynamic invocation, interoperability with dynamic languages as well as ad-hoc binding to (for example) document object models. The <code>dynamic</code> type resolves member access dynamically at runtime as opposed to statically/virtual at compile time. The member lookup mechanism is extensible with traditional reflection as a fall-back mechanism. </p> 
          <p> There are several use cases for the <code>dynamic</code> type in C#: </p> 
          <ul> 
           <li>Less verbose use of reflection: By casting an instance to the <code>dynamic</code> type, members such as properties, methods, events etc. can be directly invoked on the instance without using the reflection API directly.</li> 
           <li>Interoperability with dynamic languages: The dynamic type comes with a <a href="hub-and-spoke">hub-and-spoke</a> support for implementing dynamically typed objects and common runtime infrastructure for efficient member lookup.</li> 
           <li>Creating dynamic abstractions on the fly: For instance, a dynamic object could provide simpler access to document object models such as <a href="XML">XML</a> or <a href="XHTML">XHTML</a> documents.</li> 
          </ul> 
          <p> Java does not support a late-bound type. The use cases for C# dynamic type have different corresponding constructs in Java: </p> 
          <ul> 
           <li>For dynamic late-bound <i>by-name</i> invocation of preexisting types, reflection should be used.</li> 
           <li>For interoperability with dynamic languages, some form of interoperability API specific to that language will have to be used. The Java Virtual Machine platform does have multiple dynamic languages implemented on top of it, but there is no common standard for how to pass objects between languages. Usually this will involve some form of reflection or reflection-like API. As an example of how to use JavaFX objects from Java, see <a href="http://blogs.sun.com/javafx/entry/how_to_use_javafx_in">How to Use JavaFX in Your Swing Application</a>.</li> 
           <li>For creating and interacting with objects entirely at runtime, e.g. interaction with a document object model abstraction, a specific abstraction API will have to be used.</li> 
          </ul> 
          <p> The C# <code>dynamic</code> enables seamless interoperability with dynamic (late-bound) languages by allowing C# code to manipulate foreign objects using the same syntax as, if they were native C# objects. Lacking this capability, Java developers must use a Java based API to access such objects. Consider a Ruby class (defined in a file called <code>Deepthought.rb</code>) that has two attributes (a, b) with read/write accessors and a <code>Calculate</code> method that returns the product of the attributes. The following examples illustrate how to instantiate and use such a class from within Java and C#, respectively. </p> 
          <p> See also example <a href="#Interoperability with dynamic languages">#Interoperability with dynamic languages</a> </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Pointers </h4> 
         <div class="section-body"> 
          <p> Java does not permit pointers or pointer-arithmetic within the Java runtime environment. The Java language designers reasoned that pointers were one of the primary features that enable programmers to inject bugs into their code and chose not to support them.<span class="unknown-node">&lt;ref .../&gt;</span> Java does not allow for directly passing and receiving objects/structures to/from the underlying operating and thus does not need to model objects/structures to such a specific memory layout, layouts which frequently would involve pointers. Java's communication with the underlying operating system is instead based upon <a href="Java Native Interface">JNI</a> where communication with/adaption to an underlying operating system is handled through an external &quot;glue&quot; layer. </p> 
          <p> While C# does allow use of <a href="pointer (computer programming)">pointers</a> and corresponding pointer arithmetic, the C# language designers had the same concerns that pointers could potentially be used to bypass the strict rules for object access. Thus, C# by default also does not permit pointers.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> However, because pointers are required when calling many native functions, pointers are actually allowed in an explicit &quot;unsafe&quot; mode. Code blocks or methods that use the pointers must be marked with the <code>unsafe</code> keyword to be able to use pointers, and the compiler requires the <tt>/unsafe</tt> switch to allow compilation of such code. Assemblies are compiled using the <tt>/unsafe</tt> switch are marked as such and may only execute if explicitly trusted. This allows programmers to use pointers and pointer arithmetic to directly pass and receive objects to/from the operating system or other native APIs using the native memory layout for those objects, while at the same time isolate such potentially unsafe code in specifically trusted assemblies. </p> 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Reference types </h3> 
       <div class="section-body"> 
        <p> In both languages <a href="Reference (computer science)">references</a> are a central concept. All instances of classes are <i>by reference</i>. </p> 
        <p> While not directly evident in the language syntax <i>per se</i>, both languages support the concept of <a href="weak reference"><i>weak</i> references</a>. An instance that is only referenced by weak references is eligible for garbage collection just as if there were no references at all. In both languages this feature is exposed through the associated libraries, even though it is really a core runtime feature. </p> 
        <p> In addition to weak references, Java has <i><a href="soft reference">soft references</a></i>. Soft references are much like weak references, but the JVM will not deallocate softly-referenced objects until the memory is actually needed. </p> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> Reference types </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> <a href="Garbage collection (computer science)">Garbage collection</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Weak reference">Weak references</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Soft reference">Soft</a> and <a href="Phantom reference">Phantom</a> references </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{no}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Proxy pattern">Proxy support</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span>; proxy generation </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span>; object contexts </p> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Object orientation </h3> 
       <div class="section-body"> 
        <p> Both C# and Java are designed from the ground up as <a href="Object oriented programming">object-oriented</a> languages using <a href="dynamic dispatch">dynamic dispatch</a>, with syntax similar to <a href="C++">C++</a> (C++ in turn derives from <a href="C (programming language)">C</a>). Neither language is a superset of C or C++, however. </p> 
        <p> Both languages mainly use <a href="garbage collection (computer science)">garbage collection</a> as a means of reclaiming memory resources, rather than explicit deallocation of memory. In both cases, if an object holds resources of different kinds other than memory, such as file handles, graphical resources, etc., then it will have to be notified explicitly when the application no longer uses it. Both C# and Java offer interfaces for such deterministic <a href="dispose pattern">disposal</a> and both C# and Java (since Java 7) feature automatic resource management statements that will automatically invoke the disposal/close methods on those interfaces. </p> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> Object orientation </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> <a href="Class (computer science)">Classes</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Interface (computer science)">Interfaces</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Class (computer science)#Abstract and Concrete">Abstract classes</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Member accessibility levels </td> 
           <td> <span class="unknown-node">{{yes|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Class-level <a href="Class (computer science)#Local and inner">inner classes</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span>;<code>static</code> inner classes are class level </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span>; all inner classes are class level </p> </td> 
          </tr> 
          <tr> 
           <td> Instance-level inner classes </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{no}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Statement-level (local) <a href="Class (computer science)#Unnamed">anonymous classes</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{no}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Partial class">Partial classes</a> </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Implicit (inferred) anonymous classes </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Deprecation">Deprecation</a>/obsolescence </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Overload versioning </td> 
           <td> <span class="unknown-node">{{some}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Enums can implement interfaces </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{no}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Property (programming)">Properties</a> </td> 
           <td> <span class="unknown-node">{{no}}</span>, but see <a href="JavaBeans">JavaBeans</a> spec </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Event (computing)">Events</a> </td> 
           <td> <span class="unknown-node">{{yes|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Operator overloading">Operator overloading</a> </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Indexers </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Implicit conversions </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Explicit conversions </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <div class="section"> 
         <h4> Partial classes </h4> 
         <div class="section-body"> 
          <p> C# allows a class definition to be split across several source files using a feature called <i>partial classes</i>. Each part must be marked with the keyword <code>partial</code>. All the parts must be presented to the compiler as part of a single compilation. Parts can reference members from other parts. Parts can implement interfaces and one part can define a base class. The feature is useful in code generation scenarios (such as <a href="user interface">UI</a> design), where a code generator can supply one part and the developer another part to be compiled together. The developer can thus edit their part without the risk of a code generator overwriting that code at some later time. Unlike the class extension mechanism, a partial class allows &quot;circular&quot; dependencies among its parts as they are guaranteed to be resolved at compile time. Java has no corresponding concept. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Inner and local classes </h4> 
         <div class="section-body"> 
          <p> Both languages allow <i>inner classes</i>, where a class is defined lexically inside another class. However, in each language these inner classes have rather different semantics. </p> 
          <p> In Java, unless the inner class is declared <code>static</code>, a reference to an instance of an inner class carries a reference to the outer class with it. As a result, code in the inner class has access to both the static and non-static members of the outer class. To create an instance of a non-static inner class, one has to name the instance of the embracing outer class.<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> This is done via a new <code>new</code>-operator introduced in JDK 1.3: <code>outerClassInstance.new Outer.InnerClass()</code>. This can be done in any class that has a reference to an instance of the outer class. </p> 
          <p> In C#, an inner class is conceptually the same as a normal class. In a sense, the outer class only acts as a namespace. Thus, code in the inner class cannot access non-static members of the outer class unless it does so through an explicit reference to an instance of the outer class. Programmers can declare the inner class <i>private</i> to allow only the outer class to have any access to it. </p> 
          <p> Java provides another feature called <i>local classes</i> or <i>anonymous classes</i>, which can be defined within a method body. These are generally used to implement an interface with only one or two methods, which are typically event handlers. However, they can also be used to override virtual methods of a superclass. The methods in those local classes have access to the outer method's local variables declared <code>final</code>. C# satisfies the use-cases for these by providing anonymous <a href="Delegate (CLI)">delegates</a>; see <a href="#Event handling">event handling</a> for more about this. </p> 
          <p> C# also provides a feature called <i>anonymous types/classes</i>, but it is rather different from Java's concept with the same name. It allows the programmer to instantiate a class by providing only a set of names for the properties the class should have, and an expression to initialize each. The types of the properties are inferred from the types of those expressions. These implicitly-declared classes are derived directly from <i>object</i>. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Events </h4> 
         <div class="section-body"> 
          <p> C# multicast-delegates are called <i>events</i>. Events provide support for <a href="event-driven programming">event-driven programming</a> and is an implementation of the <a href="observer pattern">observer pattern</a>. To support this there is a specific syntax to define events in classes, and operators to register, unregister or combine event handlers. </p> 
          <p> See <a href="#Delegates / method references">here</a> for information about how events are implemented in Java. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Operator overloading and implicit and explicit conversions </h4> 
         <div class="section-body"> 
          <p> <a href="Operator overloading">Operator overloading</a> and user-defined <a href="type conversion">casts</a> are separate features that both aim to allow new types to become first-class citizens in the type system. By using these features in C#, types such as <a href="Complex numbers"><code>Complex</code></a> and <a href="decimal128"><code>decimal</code></a> have been integrated so that the usual operators like addition and multiplication work with the new types. Unlike C++, C# does restrict the use of operator overloading, prohibiting it for the operators <code>new</code>, <code>( )</code>, <code>||</code>, <code>&amp;&amp;</code>, <code>=</code>, and any variations of compound statements like <code>+=</code>. But compound operators will call overloaded simple operators, like <code>-=</code> calling <code>-</code> and <code>=</code>.<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> </p> 
          <p> Java does not include operator overloading, nor custom conversions in order to prevent abuse of the feature and to keep the language simple.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Indexers </h4> 
         <div class="section-body"> 
          <p> C# also includes <i>indexers</i> that can be considered a special case of operator overloading (like the C++ <code>operator[]</code>), or parameterized <code>get</code>/<code>set</code> properties. An indexer is a property named <code>this[]</code> that uses one or more parameters (indexes); the indices can be objects of any type: </p> 
          <p> <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> myList[4] = 5; string name = xmlNode.Attributes[&quot;name&quot;]; orders = customerMap[theCustomer]; <span class="unknown-node">&lt;/source&gt;</span> </p> 
          <p> Java does not include indexers. The common Java pattern involves writing explicit getters and setters where a C# programmer would use an indexer. </p> 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Fields and initialization </h3> 
       <div class="section-body"> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> Fields and initialization </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> <a href="Field (computer science)">Fields</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Constant (programming)">Constants</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span>; but no support for constant passed parameters<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Static (class) <a href="Constructor (object-oriented programming)">constructors</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Instance constructors </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Destructor (computer science)">Finalizers/destructors</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Instance initializers </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{no}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Object <a href="Initialization (programming)">initialization</a> </td> 
           <td> <span class="unknown-node">{{yes|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Object initializers </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Collection initializers </td> 
           <td> <span class="unknown-node">{{no}}</span>; can be modelled </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Array initializers </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <div class="section"> 
         <h4> Object initialization </h4> 
         <div class="section-body"> 
          <p> In both C# and Java, an object's fields can be initialized either by <i>variable initializers</i> (expressions that can be assigned to variables where they are defined) or by <i>constructors</i> (special subroutines that are executed when an object is being created). In addition, Java contains <i>instance initializers</i>, which are anonymous blocks of code with no arguments that are run after the explicit (or implicit) call to a superclass's constructor but before the constructor is executed. </p> 
          <p> C# initializes object fields in the following order when creating an object: </p> 
          <ol> 
           <li> Derived static fields</li> 
           <li> Derived static constructor</li> 
           <li> Derived instance fields</li> 
           <li> Base static fields</li> 
           <li> Base static constructor</li> 
           <li> Base instance fields</li> 
           <li> Base instance constructor</li> 
           <li> Derived instance constructor</li> 
          </ol> 
          <p> Some of the above fields may not be applicable (e.g. if an object does not have <i>static fields</i>). <i>Derived fields</i> are those that are defined in the object's direct class, while <i>base field</i> is a term for the fields that are defined in one of the object's superclasses. Note that an object representation in memory contains all fields defined in its class or any of its superclasses, even, if some fields in superclasses are defined as private. </p> 
          <p> It is guaranteed that any field initializers take effect before any constructors are called, since both the instance constructor of the object's class and its superclasses are called after field initializers are called. There is, however, a potential trap in object initialization when a virtual method is called from a base constructor. The overridden method in a subclass may reference a field that is defined in the subclass, but this field may not have been initialized because the constructor of the subclass that contains field initialization is called after the constructor of its base class. </p> 
          <p> In Java, the order of initialization is as follows: </p> 
          <ol> 
           <li> Invocation of another constructor (either of the object's class or of the object's superclass)</li> 
           <li> Instance variable initializers and instance initializers (in the order they appear in the source code)</li> 
           <li> The constructor body</li> 
          </ol> 
          <p> Like in C#, a new object is created by calling a specific constructor. Within a constructor, the first statement may be an invocation of another constructor. If this is omitted, the call to the argumentless constructor of the superclass is added implicitly by the compiler. Otherwise, either another overloaded constructor of the object's class can be called explicitly, or a superclass constructor can be called. In the former case, the called constructor will again call another constructor (either of the object's class or its subclass) and the chain sooner or later ends up at the call to one of the constructors of the superclass. </p> 
          <p> After another constructor is called (that causes direct invocation of the superclass constructor, and so forth, down to the Object class), instance variables defined in the object's class are initialized. Even if there are no variable initializers explicitly defined for some variables, these variables are initialized to default values. Note that instance variables defined in superclasses are already initialized by this point, because they were initialized by a superclass constructor when it was called (either by the constructor's code or by variable initializers performed before the constructor's code or implicitly to default values). In Java, variable initializers are executed according to their textual order in the source file. </p> 
          <p> Finally, the constructor body is executed. This ensures proper order of initialization, i.e. the fields of a base class finish initialization before initialization of the fields of an object class begins. </p> 
          <p> There are two main potential traps in Java's object initialization. First, variable initializers are expressions that can contain method calls. Since methods can reference any variable defined in the class, the method called in a variable initializer can reference a variable that is defined below the variable being initialized. Since initialization order corresponds to textual order of variable definitions, such a variable would not be initialized to the value prescribed by its initializer and would contain the default value. Another potential trap is when a method that is overridden in the derived class is called in the base class constructor, which can lead to behavior the programmer would not expect when an object of the derived class is created. According to the initialization order, the body of the base class constructor is executed before variable initializers are evaluated and before the body of the derived class constructor is executed. The overridden method called from the base class constructor can, however, reference variables defined in the derived class, but these are not yet initialized to the values specified by their initializers or set in the derived class constructor. The latter issue applies to C# as well, but in a less critical form since in C# methods are not overridable by default. </p> 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Methods and properties </h3> 
       <div class="section-body"> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> Methods and properties </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> Static imports </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{no}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Virtual methods </td> 
           <td> <span class="unknown-node">{{yes|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Abstraction (computer science)">Abstract</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Sealing </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Explicit interface implementation </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span><span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Value (input) parameters </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Reference (input/output) parameters </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Output (output) parameters </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Constant (immutable) parameters </td> 
           <td> <span class="unknown-node">{{yes}}</span>;<a href="#Constant/immutable parameters">final</a> parameters </td> 
           <td> <p> <span class="unknown-node">{{no}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Variadic function">Variadic methods</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Optional arguments </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Named arguments </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Generator (computer programming)">Generator methods</a> </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Extension methods </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Conditional methods </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Partial methods </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <div class="section"> 
         <h4> Extension methods </h4> 
         <div class="section-body"> 
          <p> Using a special <i>this</i> designator on the first parameter of a method, C# allows the method to act as if it were a member method of the type of the first parameter. This <i>extension</i> of the foreign class is purely syntactical. The extension method needs to be static and defined within a purely static class. It must obey any restriction on such external static methods and thus cannot break object encapsulation. The &quot;extension&quot; is only active within scopes where the namespace of the static host class has been imported. Java does not have an equivalent feature (although one is being discussed for Java 8). </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Partial methods </h4> 
         <div class="section-body"> 
          <p> Related to <i>partial classes</i> C# allows partial methods to be specified within partial classes. A partial method is an intentional declaration of a method with a number of restrictions on the signature. These restrictions ensure that if a definition is not actually provided by any class part, then the method and every call to it can be safely erased.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> This feature allows code to provide a large number of interception points (like the <a href="Template method pattern">template method</a> <a href="Design Patterns">GoF</a> design pattern) without paying any runtime overhead if these extension points are not being used by another class part at compile time. Java has no corresponding concept. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Virtual methods </h4> 
         <div class="section-body"> 
          <p> <i>Methods</i> in C# are non-<a href="Virtual function">virtual</a> by default, and have to be declared virtual explicitly, if desired. In Java, all non-static non-private methods are virtual. Virtuality guarantees that the most recent <a href="Method overriding (programming)">override</a> for the method will always be called, but incurs a certain runtime cost on invocation as these invocations cannot be normally <a href="Inline expansion">inlined</a>, and require an indirect call via the <a href="virtual method table">virtual method table</a>. However, some JVM implementations, including the Sun reference implementation, implement inlining of the most commonly called virtual methods. </p> 
          <p> Java methods are virtual by default (although they can be &quot;sealed&quot; by using the <code>final</code> modifier to disallow overriding). There is no way to let <a href="subclass (computer science)">derived classes</a> define a new, unrelated method with the same name. </p> 
          <p> This means that by default in Java, and only when explicitly enabled in C#, new methods may be defined in a derived class with the same name and signature as those in its base class. When the method is called on a superclass reference of such an object, the &quot;deepest&quot; overridden implementation of the <a href="base class">base class</a>' method will be called according to the specific subclass of the object being referenced. </p> 
          <p> In some cases, when a subclass introduces a method with the same name and signature as a method already present in the <a href="base class">base class</a>, problems can occur. In Java, this will mean that the method in the derived class will implicitly override the method in the base class, even though that may not be the intent of the designers of either class. </p> 
          <p> To mitigate this, C# requires that if a method should be overridden, the <code>override</code> keyword must be specified. Otherwise, the method will &quot;hide&quot; the inherited method. A compiler warning to this effect is issued, which can be silenced by specifying the <code>new</code> keyword. This avoids the problem that can arise from a base class being extended with a protected/public method whose signature is already in use by a derived class. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Constant/immutable parameters </h4> 
         <div class="section-body"> 
          <p> In Java, it is possible to make the passed parameters to a method unchangeable by using the <span class="unknown-node">{{Java|...}}</span> keyword. The language C# does not have this functionality.<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> </p> 
          <table class="wikitable"> 
           <tbody>
            <tr> 
             <th> Java </th> 
             <th> <p> C# </p> </th> 
            </tr> 
            <tr> 
             <td> <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> </p> <pre>   /**
    * Getter for a value from the value array
    * @param INDEX
    * @return Requested value or -1, if the index is out of bounds.
    */
   public short getValue(final short INDEX) {
       if (INDEX &lt; values.length) {
           INDEX++;    // ERROR: The final local variable INDEX cannot be assigned.
                       // It must be blank and not using a compound assignment
           return values[INDEX];
       }
       else return -1;
   }<span class="unknown-node">&lt;/source&gt;</span> || 
               <center>
                no C# language equivalent
               </center>
</pre> </td> 
            </tr> 
           </tbody>
          </table> 
          <p> This missing feature, however, has only limited use. For primitive types that are implemented as <a href="call by value">call by value</a>, a modified value of a passed parameter inside the method does not affect the caller. Thus, for primitive types, to pass a parameter as <span class="unknown-node">{{Java|...}}</span> is only preventing a change of this parameter's value. For passed objects, a <span class="unknown-node">{{Java|...}}</span> parameter would prevent that another object is assigned to it, which is indeed a gain. It will, however, not prevent that the value contained by the object is safe. </p> 
          <p> Both languages do not support essential feature of <a href="const-correctness">const-correctness</a> that exists in <a href="C (programming language)">C</a>/<a href="C++">C++</a>, which makes a method constant.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Generator methods </h4> 
         <div class="section-body"> 
          <p> <span class="unknown-node">{{further|...}}</span> Any C# method declared as returning <code>IEnumerable</code>, <code>IEnumerator</code> or the generic versions of these interfaces can be implemented using <code>yield</code> syntax. This is a form of limited, compiler-generated continuations and can drastically reduce the code required to traverse or generate sequences, although that code is just generated by the compiler instead. The feature can also be used to implement infinite sequences, e.g. the sequence of <a href="Fibonacci numbers">Fibonacci numbers</a>. </p> 
          <p> Java does not have an equivalent feature. Instead generators are typically defined by providing a specialized implementation of a well-known collection or iterable interface, which will compute each element on demand. For such a generator to be used in a <i>for each</i> statement, it must implement interface <code>java.lang.Iterable</code>. </p> 
          <p> See also example <a href="#Fibonacci sequence">Fibonacci sequence</a> below. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Explicit interface implementation </h4> 
         <div class="section-body"> 
          <p> C# also has <i>explicit interface implementation</i> that allows a class to specifically implement methods of an <a href="interface (computer science)">interface</a>, separate to its own class methods, or to provide different implementations for two methods with the same name and signature inherited from two base interfaces. </p> 
          <p> In either language, if a method (or property in C#) is specified with the same name and signature in multiple interfaces, the members will clash when a class is designed that implements those interfaces. An implementation will by default implement a common method for all of the interfaces. If separate implementations are required (because the methods really do serve separate purposes, or because return values differ between the interfaces) C#'s explicit interface implementation will solve the problem, though allowing different results for the same method, depending on the current cast of the object. In Java there is no way to solve this problem other than refactoring one or more of the interfaces to avoid name clashes.<span class="unknown-node">&lt;ref .../&gt;</span> </p> 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Reference (input/output) parameters </h3> 
       <div class="section-body"> 
        <p> The arguments to a method are passed by value in Java, if they are primitive types and not objects. The String is also treated like a primitive type. This means that a method operates on copies of the items passed to it instead of on the actual items. In C#, it is possible to enforce a reference with the <code lang="CSharp">ref</code> keyword, similar to C++ and in a sense to C. This feature of C# is particularly useful when one wants to create a method that returns more than one object. In Java trying to return multiple values from a method is not supported.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
        <p> See also example <a href="#Pass by reference">#Pass by reference</a> below. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Generics </h3> 
       <div class="section-body"> 
        <p> <span class="unknown-node">{{Further|...}}</span> </p> 
        <p> In the field of <a href="generic programming">generics</a> the two languages show a superficial syntactical similarity, but they have deep underlying differences. </p> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> Generics </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> Implementation </td> 
           <td> <span class="unknown-node">{{yes|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Runtime realization </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Covariance and contravariance (computer science)">Covariance</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Covariance and contravariance (computer science)">Contravariance</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Reference type constraint </td> 
           <td> <span class="unknown-node">{{yes}}</span>; implicit </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Value/primitive type constraint </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Constructor constraint </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Relation constraint </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Primitive/value type support </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Migration compatibility </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{no}}</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <div class="section"> 
         <h4> Type erasure versus reified generics </h4> 
         <div class="section-body"> 
          <p> <a href="Generics in Java">Generics in Java</a> are a language-only construction; they are implemented only in the compiler. The generated classfiles include generic signatures only in form of metadata (allowing the compiler to compile new classes against them). The runtime has no knowledge of the generic type system; generics are not part of the <a href="JVM">JVM</a>. Instead, generics classes and methods are transformed during compilation through a process known as <a href="type erasure">type erasure</a>. During this process the compiler replaces all generic types with their <i>raw</i> version and inserts casts/checks appropriately in client code where the type and its methods are used. The resulting byte code will contain no references to any generic types or parameters (See also <a href="Generics in Java">Generics in Java</a>). <br /> The language specification intentionally prohibits certain uses of generics; this is necessary to allow for implementing generics through <a href="type erasure">type erasure</a>, and to allow for migration compatibility.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
          <p> C# builds on support for generics from the virtual execution system itself, i.e. it is not just a language feature. The language is merely a front-end for cross-language generics support in the <a href="Common Language Runtime">CLR</a>. During compilation generics are verified for correctness, but code generation for actually <i>implementing</i> the generics are deferred to class-load time. Client code (code invoking generic methods/properties) are fully compiled and can safely assume generics to be type-safe. This is called <a href="Reification (computer science)">reification</a>. At runtime, when a unique set of type parameters for a generic class/method/delegate is encountered for the first time, the class loader/verifier will synthesize a concrete class descriptor and generate method implementations. During the generation of method implementations all reference types will be considered a single type, as reference types can safely share the same implementations. Note, this is merely for the purpose of <i>implementing</i> code. Different sets of reference types will still have unique type descriptors; their method tables will merely point to the same code. </p> 
          <p> The following list illustrates some differences between Java and C# when managing generics. It is not exhaustive:<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
          <table class="wikitable"> 
           <tbody>
            <tr> 
             <th style="width:50%;"> Java </th> 
             <th style="width:50%;"> <p> C# </p> </th> 
            </tr> 
            <tr> 
             <td> <p> Type checks and downcasts are injected into client code (the code <i>referencing</i> the generics). Compared to non-generic code with manual casts, these casts will be the same,<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> but compared to compile-time verified code that would not need runtime casts and checks, these operations represent a performance overhead. </p> </td> 
             <td> <p> C#/.NET generics guarantee type-safety and are verified at compile time, making extra checks/casts are unnecessary at runtime. Hence, generic code will run <i>faster</i> than non-generic (or type-erased) code that require casts when handling non-generic or type-erased objects. </p> </td> 
            </tr> 
            <tr> 
             <td> <p> Cannot use primitive types as type parameters; instead, the developer must use the wrapper type corresponding to the primitive type. This incurs extra performance overhead by requiring boxing and unboxing conversions as well a memory and garbage collection pressure, as the wrappers will be heap-allocated as opposed to stack-allocated. </p> </td> 
             <td> <p> Primitive and value types are allowed as type parameters in generic realizations. At runtime code will be synthesized and compiled for each unique combination of type parameters upon first use. Generics that are realized with primitive/value type do not require boxing/unboxing conversions. </p> </td> 
            </tr> 
            <tr> 
             <td> <p> Generic exceptions are not allowed<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> and a type parameter cannot be used in a catch clause<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
             <td> <p> Can both define generic exceptions and use those in catch clauses </p> </td> 
            </tr> 
            <tr> 
             <td> <p> Static members are shared across all generic realizations<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> (during type erasure all realizations are folded into a single class) </p> </td> 
             <td> <p> Static members are separate for each generic realization. A generic realization is a unique class. </p> </td> 
            </tr> 
            <tr> 
             <td> <p> Type parameters cannot be used in declarations of static fields/methods or in definitions of static inner classes </p> </td> 
             <td> <p> No restrictions on use of type parameters </p> </td> 
            </tr> 
            <tr> 
             <td> <p> Cannot create an array where the component type is a generic realization (concrete parameterized type) <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> Object tenPairs = </p> <pre>   new Pair&lt;Integer, String&gt;[10]; // error
</pre> <p> <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
             <td> <p> A generic realization is a 1st class citizen and can be used as any other class; also an array component <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> object tenPairs = </p> <pre>   new Pair&lt;int, string&gt;[10]; // OK
</pre> <p> <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
            </tr> 
            <tr> 
             <td> <p> Cannot create an array where the component type is a type parameter <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> public class Lookup&lt;TKey,TValue&gt; { </p> <pre>   public TValue[] getEmptyValues(TKey key) {
       return new TValue[0]; // error
   }
</pre> <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
             <td> <p> Type parameters represent actual, discrete classes and can be used like any other type within the generic definition. <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> public class Lookup&lt;TKey, TValue&gt; { </p> <pre>   public TValue[] GetEmptyValues(TKey key) {
       return new TValue[0]; // OK
   }
</pre> <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
            </tr> 
            <tr> 
             <td> <p> There is no class literal for a concrete realization of a generic type </p> </td> 
             <td> <p> A generic realization is an actual class. </p> </td> 
            </tr> 
            <tr> 
             <td> <p> <code>instanceof</code> is not allowed with type parameters or concrete generic realizations </p> </td> 
             <td> <p> The <code>is</code> and <code>as</code> operators work the same for type parameters as for any other type. </p> </td> 
            </tr> 
            <tr> 
             <td> <p> Cannot create new instances using a type parameter as the type </p> </td> 
             <td> <p> With a constructor constraint, generic methods or methods of generic classes can create instances of classes that have default constructors. </p> </td> 
            </tr> 
            <tr> 
             <td> <p> Type information is erased during compilation. Special extensions to reflection must be used to discover the original type. </p> </td> 
             <td> <p> Type information about C# generic types is fully preserved at runtime, and allows complete reflection support as well as instantiation of generic types. </p> </td> 
            </tr> 
            <tr> 
             <td> <p> Reflection cannot be used to construct new generic realizations. During compilation extra code (typecasts) are injected into the <i>client</i> code of generics. This precludes creating new realizations later. </p> </td> 
             <td> <p> Reflection can be used to create new realizations for new combinations of type parameters. </p> </td> 
            </tr> 
           </tbody>
          </table> 
          <p> C# allows generics directly for primitive types. Java, instead, allows the use of boxed types as type parameters (e.g., <code>List&lt;Integer&gt;</code> instead of <code>List&lt;int&gt;</code>). This comes at a cost since all such values need to be boxed/unboxed when used, and they all need to be heap-allocated. However, a generic type can be specialized with an array type of a primitive type in Java, for example <code>List&lt;int[]&gt;</code> is allowed.<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Migration compatibility </h4> 
         <div class="section-body"> 
          <p> Java's type erasure design was motivated by a design requirement to achieve <i>migration compatibility</i> - not to be confused with <a href="backward compatibility">backward compatibility</a>. In particular, the original requirement was &quot;<i>? there should be a clean, demonstrable migration path for the Collections APIs that were introduced in the Java 2 platform</i>&quot;.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> This was designed so that any new generic collections should be passable to methods that expected one of the pre-existing collection classes.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
          <p> C# generics were introduced into the language while preserving full backward compatibility, but did not preserve full <i>migration compatibility</i>: Old code (pre C# 2.0) runs unchanged on the new generics-aware runtime without recompilation. As for <i>migration compatibility</i>, new generic collection classes and interfaces were developed that supplemented the non-generic .NET 1.x collections rather than replacing them. In addition to generic collection interfaces, the new generic collection classes implement the non-generic collection interfaces where possible. This prevents the use of new generic collections with pre-existing (non-generic aware) methods, if those methods are coded to use the collection <i>classes</i>. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Covariance and contravariance </h4> 
         <div class="section-body"> 
          <p> <span class="unknown-node">{{Further|...}}</span> Covariance and contravariance is supported by both languages. Java has use-site variance that allows a single generic class to declare members using both co- and contravariance. C# has define-site variance for generic interfaces and delegates. Variance is not supported directly on classes but is supported through their implementation of variant interfaces. C# also has use-site covariance support for methods and delegates. </p> 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Functional programming </h3> 
       <div class="section-body"> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> <a href="#Functional programming">Functional programming</a> </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> Method references </td> 
           <td> <span class="unknown-node">{{no}}</span>; but see <a href="#Delegates / method references">Delegates / method references</a> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Closure (computer science)">Closures</a> </td> 
           <td> <span class="unknown-node">{{no}}</span>; but see <a href="#Delegates / method references">Delegates / method references</a> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="lambda expressions">lambda expressions</a> </td> 
           <td> <span class="unknown-node">{{no}}</span>; but see <a href="#Delegates / method references">Delegates / method references</a> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Abstract syntax tree">Expression trees</a> </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Generic query language </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <div class="section"> 
         <h4> Closures </h4> 
         <div class="section-body"> 
          <p> A closure is an inline function that captures variables from its lexical scope. </p> 
          <p> C# supports closures as anonymous methods or <a href="Anonymous function#C#lambda expressions">lambda expressions</a> with full-featured <a href="Closure (computer science)">closure</a> semantics.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
          <p> In Java, anonymous inner classes remains the preferred way to emulate closures. This is a more verbose construction. </p> 
          <p> This approach also has some differences compared to real closures, notably more controlled access to variables from the enclosing scopes: only final members can be referenced. </p> 
          <p> When a reference to a method can be passed around for later execution, a problem arises about what to do when the method has references to variables/parameters in its lexical scope. C# closures can access any variable/parameter from its lexical scope. In Java's anonymous inner classes, only references to final members of the lexical scope are allowed, thus requiring the developer to mark which variables to make available, and in what state (possibly requiring boxing). </p> 
          <p> While Java does not currently feature closures, it has been announced that some form of closures or lambdas will be included in JDK 8 that at latest update (10 October 2010) is scheduled for release &quot;late 2012&quot;.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Lambdas and expression trees </h4> 
         <div class="section-body"> 
          <p> C# features a special type of in-line <a href="Closure (computer science)">closures</a> called <a href="Anonymous function#C#lambda expressions">lambdas</a>. These are anonymous methods: they have a signature and a body, but no name. They are mainly used to specify local function-valued arguments in calls to other methods, a technique mainly associated with <a href="functional programming">functional programming</a>. On top of that, lambda functions can double as a way to define special data structures called expression trees. Whether they are seen as an executable function or as a data structure depends on compiler <a href="type inference">type inference</a> and what type of variable or parameter they are assigned or cast to. Lambdas and expression trees play key roles in <a href="LINQ">LINQ</a>. Java does not feature lambdas or expression trees; its primary mechanism for inline scope capture and method definition is the anonymous inner class syntax. </p> 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Late binding </h3> 
       <div class="section-body"> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> <a href="#Runtime binding">Runtime (dynamic) binding</a> </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> Late-bound (dynamic) type </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Runtime type information and manipulation </h3> 
       <div class="section-body"> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> <a href="#Runtime type information and manipulation">Runtime type information and manipulation</a> </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> Runtime type information </td> 
           <td> <span class="unknown-node">{{yes}}</span>; but with type erasure </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Runtime generics realization </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Runtime type construction </td> 
           <td> <span class="unknown-node">{{no}}</span>; third party tools exist </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Statements </h3> 
       <div class="section-body"> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> Statements </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> <a href="Loop (computing)">Loops</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Conditional (programming)">Conditionals</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Flow control </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Assignment (computer science)">Assignment</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Exception control </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Variable declaration </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Variable type inference </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Deterministic disposal (ARM-blocks) </td> 
           <td> <span class="unknown-node">{{yes}}</span> (starting with <a href="Java 7">Java 7</a>) </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Expressions and operators </h3> 
       <div class="section-body"> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> Expressions and operators </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> Arithmetic operators </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Logical operators </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Bitwise logic operators </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Conditional </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> String concatenation </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Casts </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Boxing (programming)">Boxing</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span>; implicit </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span>; implicit </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Auto-unboxing">Unboxing</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span>; implicit </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span>; explicit </p> </td> 
          </tr> 
          <tr> 
           <td> Lifted operators </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Overflow control </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Strict floating point evaluation </td> 
           <td> <span class="unknown-node">{{yes}}</span>; opt-in/out </td> 
           <td> <p> <span class="unknown-node">{{no}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Verbatim (here-)strings </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <div class="section"> 
         <h4> Boxing and unboxing </h4> 
         <div class="section-body"> 
          <p> Both languages allow <a href="autoboxing">automatic boxing</a> and unboxing, i.e. they allow for implicit casting between any primitive types and the corresponding reference types. <br /> In C#, the primitive types are subtypes of the Object type. In Java this is not true; any given primitive type and the corresponding wrapper type have no specific relationship with each other, except for autoboxing and unboxing, which act as <a href="syntactic sugar">syntactic sugar</a> for interchanging between them. This was done intentionally, to maintain backward compatibility with prior versions of Java, in which no automatic casting was allowed, and the programmer worked with two separate sets of types: the primitive types, and the wrapper (reference) type hierarchy.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
          <p> This difference has the following consequences. First of all, in C#, primitive types can define methods, such as an override of Object's <code>ToString()</code> method. In Java, this task is accomplished by the <a href="primitive wrapper class">primitive wrapper classes</a>. <br /> Secondly, in Java an extra cast is needed whenever one tries to directly <a href="Reference (computer science)">dereference</a> a primitive value, as it will not be boxed automatically. The expression <code>((Integer)42).toString()</code> will convert an integer literal to string in Java while <code>42.ToString()</code> performs the same operation in C#. This is because the latter one is actually an instance call on the primitive value <code>42</code>, while the former one is an instance call on an object of type <tt>java.lang.Integer</tt>. </p> 
          <p> Finally, another difference is that Java makes heavy use of boxed types in <a href="Generic programming">generics</a> (see <a href="#Generics">below</a>). </p> 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Exceptions </h3> 
       <div class="section-body"> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> Exceptions </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> Checked exceptions </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{no}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Try-catch-finally </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <div class="section"> 
         <h4> Checked exceptions </h4> 
         <div class="section-body"> 
          <p> Java supports <a href="checked exceptions">checked exceptions</a> (in addition to <a href="checked exceptions">unchecked exceptions</a>). C# only supports unchecked exceptions. Checked exceptions force the programmer to either declare the exception thrown in a method, or to catch the thrown exception using a <code>try-catch</code> clause. </p> 
          <p> Checked exceptions can encourage good programming practice, ensuring that all errors are dealt with. However <a href="Anders Hejlsberg">Anders Hejlsberg</a>, chief C# language architect, argues that they were to some extent an experiment in Java and that they have not been shown to be worthwhile except in small example programs.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
          <p> One criticism is that checked exceptions encourage programmers to use an empty catch block (<code>catch (Exception e) {}</code>),<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> which silently swallows exceptions, rather than letting the exceptions propagate to a higher-level exception-handling routine. In some cases, however, <a href="exception chaining">exception chaining</a> can be applied instead, by re-throwing the exception in a wrapper exception. For example, if an object is changed to access a database instead of a file, an <span class="unknown-node">{{Javadoc:SE|...}}</span> could be caught and re-thrown as an <span class="unknown-node">{{Javadoc:SE|...}}</span>, since the caller may not need to know the inner workings of the object. </p> 
          <p> However, not all programmers agree with this stance, with James Gosling and others maintaining that checked exceptions are a good idea and it's people misusing them that cause the issues. Silently catching exceptions is possible, yes, but you have to explicitly say what you want to do with the exception as oppose to unchecked exceptions that let you do nothing by default. You can ignore it, but you have to explicitly write code to ignore it.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Try-catch-finally </h4> 
         <div class="section-body"> 
          <p> There are also differences between the two languages in treating the <code>try-finally</code> statement. The <code>finally</code> block is always executed, even if the <code>try</code> block contains control-passing statements like <code>throw</code> or <code>return</code>. In Java, this may result in unexpected behavior, if the <code>try</code> block is left by a <code>return</code> statement with some value, and then the <code>finally</code> block that is executed afterward is also left by a <code>return</code> statement with a different value. C# resolves this problem by prohibiting any control-passing statements like <code>return</code> or <code>break</code> in the <code>finally</code> block. </p> 
          <p> A common reason for using <code>try-finally</code> blocks is to guard resource managing code, thus guaranteeing the release of precious resources in the finally block. C# features the <code>using</code> statement as a syntactic shorthand for this common scenario, in which the <code>Dispose()</code> method of the object of the <code>using</code> is always called. </p> 
          <p> A rather subtle difference is the moment a stack trace is created when an exception is being thrown. In Java, the stack trace is created in the moment the exception is created. </p> 
          <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> class Foo { </p> 
          <pre>   Exception e = new Exception();
   int foo() throws Exception {
       throw e;
   }
</pre> 
          <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> 
          <p> The exception in the statement above will always contain the constructor's stack-trace - no matter how often foo is called. In C# on the other hand, the stack-trace is created the moment &quot;throw&quot; is executed. <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> class Foo { </p> 
          <pre>   Exception e = new Exception();
   int foo() 
   {
       try 
       {
           throw e;
       } 
       catch (Exception e) 
       {
           throw;
       }
   }
</pre> 
          <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> 
          <p> In the code above, the exception will contain the stack-trace of the first throw-line. When catching an exception, there are two options in case the exception should be rethrown: <code>throw</code> will just rethrow the original exception with the original stack, while <code>throw e</code> would have created a new stack trace. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Finally blocks </h4> 
         <div class="section-body"> 
          <p> Java allows flow of control to leave the <code>finally</code> block of a <code>try</code> statement, regardless of the way it was entered. This can cause another control flow statement (such as <code>return</code>) to be terminated mid-execution. For example: </p> 
          <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> int foo() { </p> 
          <pre>   try {
       return 0;
   } finally {
       return 1;
   }
</pre> 
          <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> 
          <p> In the above code, the <code>return</code> statement within <code>try</code> block causes control to leave it, and therefore <code>finally</code> block is executed before the actual return happens. However, <code>finally</code> block itself performs a return as well; thus, the original return that caused it to be entered is not actually executed, and the above method returns 1 rather than 0. </p> 
          <p> C# does not allow any statements that allow control flow to leave the <code>finally</code> block prematurely, except for <code>throw</code>. In particular, <code>return</code> is not allowed at all, <code>goto</code> is not allowed, if the target label is outside the <code>finally</code> block, and <code>continue</code> and <code>break</code> are not allowed, if the nearest enclosing loop is outside the <code>finally</code> block. </p> 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Arrays and collections </h3> 
       <div class="section-body"> 
        <p> <a href="Array data structure">Arrays</a> and <a href="Collection (computing)">collections</a> are concepts featured by both languages. </p> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> <a href="Array data type">Arrays</a> and <a href="Collection (computing)">Collections</a> </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> <a href="Abstract data type">Abstract data types</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> One-dimensional, zero-based index arrays </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Multidimensional arrays, rectangular (single array) </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Multidimensional arrays, jagged (arrays of arrays) </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Non-zero based arrays </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{some}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Unified arrays and collections </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Associative array">Maps/dictionaries</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Sorted dictionaries </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Sets </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Sorted sets </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Lists/vectors </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Queue (data structure)">Queues/stacks</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Priority queue">Priority queue</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{no}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Bags/multisets </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Concurrency optimized collections </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <p> The syntax used to declare and access arrays is identical, except that C# has added syntax for declaring and manipulating multidimensional arrays. </p> 
        <table class="wikitable" style="width:90%;"> 
         <tbody>
          <tr> 
           <th style="width:50%;"> Java </th> 
           <th style="width:50%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> <p> Arrays are implicitly direct specializations of <code>Object</code>. They are not unified with collection types. </p> </td> 
           <td> <p> Arrays in C# are implicit specializations of the <code>System.Array</code> class that implements a number of collection interfaces. </p> </td> 
          </tr> 
          <tr> 
           <td> <p> Arrays and collections are completely separate with no unification. Arrays cannot be passed where sequences or collections are expected </p> </td> 
           <td> <p> Arrays can be passed where sequences (<code>IEnumerable</code>s) or collections/list interfaces are expected. However, the collection operations that alter the number of elements (insert/add/remove) will throw exceptions as these operations are not supported by arrays. </p> </td> 
          </tr> 
          <tr> 
           <td> <p> The <code>for</code> statement accepts either arrays or <code>Iterable</code>s. All collections implement <code>Iterable</code>. This means that the same short syntax can be used in for-loops. </p> </td> 
           <td> <p> The <code>foreach</code> statement iterates through a sequence using the <code>IEnumerable</code> or<code>IEnumerable&lt;T&gt;</code> interface. Because arrays always implicitly implement these interfaces, the loop will iterate through arrays as well. </p> </td> 
          </tr> 
          <tr> 
           <td colspan="2"> <p> In both languages arrays are covariant. This means that a <code>String[]</code> array is assignable to variables of <code>Object[]</code> because <code>String</code> is a specialization of (assignable to) <code>Object</code>. In both languages the arrays will perform a type check when inserting new values because type-safety would otherwise be compromised. This is in contrast to how generic collections have been implemented in both languages. </p> </td> 
          </tr> 
          <tr> 
           <td> <p> No <a href="Array_data_structure#Two-dimensional_arrays">multidimensional arrays</a> (rectangular arrays), but arrays of references to arrays (<a href="Array data structure#Efficiency comparison with other data structures">jagged arrays</a>). </p> </td> 
           <td> <p> <a href="Array_data_structure#Two-dimensional_arrays">Multidimensional arrays</a> (rectangular arrays), as well as arrays of references to arrays (<a href="Array data structure#Efficiency comparison with other data structures">jagged arrays</a>). </p> </td> 
          </tr> 
          <tr> 
           <td> <p> Arrays cannot be resized (though use of the <code>System.arraycopy()</code> method can allow for multi-step array resizing) </p> </td> 
           <td> <p> Arrays can be resized while preserving existing values using the <code>Array.Resize()</code> static array method. </p> </td> 
          </tr> 
          <tr> 
           <td> <p> Implemented as a <a href="retrofit">retrofit</a> for the <code lang="Java">java.util</code> library having extra features, like data structures like sets and linked sets that are not present in C#, and has a number of algorithms to manipulate elements of a collection, like finding the largest element based on some Comparator object, finding the smallest element, finding sublists within a list, reverse the contents of a list, shuffle the contents of a list, create immutable versions of a collection, performs sorts, and make binary searches.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
           <td> <p> The C# collections framework consists of classes from the <code language="CSharp">System.Collections</code> and the <code language="CSharp">System.Collections.Generic</code> namespaces with a number of useful interfaces, abstract classes, and data structures.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <p> Multidimensional arrays can in some cases increase performance because of increased <a href="Memory locality">locality</a> (as there is a single pointer dereference instead of one for every dimension of the array, as is the case for jagged arrays). However, since all array element access in a multidimensional array requires multiplication/shift between the two or more dimensions, this is an advantage only in very random access scenarios. </p> 
        <p> Another difference is that the entire multidimensional array can be allocated with a single application of operator <code>new</code>, while jagged arrays require loops and allocations for every dimension. Note, though, that Java provides a syntactic construct for allocating a jagged array with regular lengths; the loops and multiple allocations are then performed by the virtual machine and need not be explicit at the source level. </p> 
        <p> Both languages feature an extensive set of collection types that includes various ordered and unordered types of lists, maps/dictionaries, sets, etc. </p> 
        <p> Java does support also the syntax of C/C++, which is not so clear to read:<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
        <table class="wikitable"> 
         <tbody>
          <tr> 
           <th> Java </th> 
           <th> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> </p> <pre>// Is valid, as numbers is an object of type short[] 
short[] numbers = new short[100];
// Is valid, but it isn't clear that values 
// is an object of type double[]
double values[] = new double[100];<span class="unknown-node">&lt;/source&gt;</span> || <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span>
// Is valid, as numbers is an object of type short[] 
short[] numbers = new short[100];
double values[] = new double[100]; // Won't compile!<span class="unknown-node">&lt;/source&gt;</span>
</pre> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Metadata annotations </h3> 
       <div class="section-body"> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> <a href="Metadata">Metadata</a> </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> Metadata annotations/attributes </td> 
           <td> <span class="unknown-node">{{yes|...}}</span>; user-defined annotations can be created<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Positional arguments </td> 
           <td> <span class="unknown-node">{{no}}</span>; unless a single argument </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Named arguments </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Default values </td> 
           <td> <span class="unknown-node">{{yes|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Nested types </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Specialization </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Conditional metadata </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Preprocessing, compilation and packaging </h3> 
       <div class="section-body"> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> <a href="Preprocessor">Preprocessing</a>, <a href="Compiler">Compilation</a> and <a href="Modular programming">Packaging</a> </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> <a href="Namespace (computer science)">Namespaces</a> </td> 
           <td> <span class="unknown-node">{{yes|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> File contents </td> 
           <td> <span class="unknown-node">{{no|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Packaging </td> 
           <td> <span class="unknown-node">{{yes|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Classes/assembly search path </td> 
           <td> <span class="unknown-node">{{partial|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Conditional compilation </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Custom errors/warnings </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Explicit regions </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <div class="section"> 
         <h4> Namespaces and file contents </h4> 
         <div class="section-body"> 
          <p> In C#, <a href="Namespace (computer science)">namespaces</a> are similar to those in <a href="C++">C++</a>. Unlike <a href="Java package">package</a> names in Java, a namespace is not in any way tied to the location of the source file. While it is not strictly necessary for a Java source file location to mirror its package directory structure, it is the conventional organization. </p> 
          <p> Both languages allow importing of classes (e.g., <code><b>import</b> java.util.*</code> in Java), allowing a class to be referenced using only its name. Sometimes classes with the same name exist in multiple namespaces or packages. Such classes can be referenced by using fully qualified names, or by importing only selected classes with different names. To do this, Java allows importing a single class (e.g., <code><b>import</b> java.util.List</code>). C# allows importing classes under a new local name using the following syntax: <code><b>using</b> Console = System.Console</code>. It also allows importing specializations of classes in the form of <code><b>using</b> IntList = System.Collections.Generic.List&lt;<b>int</b>&gt;</code>. </p> 
          <p> Java has a <a href="static import">static import</a> syntax that allows using the short name of some or all of the static methods/fields in a class (e.g., allowing <code>foo(bar)</code> where <code>foo()</code> can be statically imported from another class). C# has a static class syntax (not to be confused with static inner classes in Java), which restricts a class to only contain static methods. C# 3.0 introduces <a href="extension method">extension methods</a> to allow users to statically add a method to a type (e.g., allowing <code>foo.bar()</code> where <code>bar()</code> can be an imported extension method working on the type of <code>foo</code>). </p> 
          <p> The <a href="Sun Microsystems">Sun Microsystems</a> Java compiler requires that a source file name must match the only public class inside it, while C# allows multiple public classes in the same file, and puts no restrictions on the file name. C# 2.0 and later allows splitting a class definition into several files by using the <code>partial</code> keyword in the source code. In Java, a public class will always be in its own source file. In C#, source code files and logical units separation are not tightly related. </p> 
         </div> 
        </div> 
        <div class="section"> 
         <h4> Conditional compilation </h4> 
         <div class="section-body"> 
          <p> Unlike Java, C# implements <a href="conditional compilation">conditional compilation</a> using <a href="preprocessor directive">preprocessor directives</a>. It also provides a <code>Conditional</code> <a href="Annotation">attribute</a> to define methods that are only called when a given compilation constant is defined. This way, <a href="Assertion (computing)">assertions</a> can be provided as a framework feature with the method <code>Debug.Assert()</code>, which is only evaluated when the <code>DEBUG</code> constant is defined. Since version 1.4, Java provides a language feature for assertions, which are turned off at runtime by default but can be enabled using the <code>-enableassertions</code> or <code>-ea</code> switch when invoking the JVM. </p> 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Threading and asynchronous features </h3> 
       <div class="section-body"> 
        <p> Both languages include thread <a href="synchronization">synchronization</a> mechanisms as part of their language syntax. </p> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> <a href="Thread (computer science)">Threading</a> and <a href="Synchronization (computer science)">Synchronization</a> </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> Threads </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Thread pool pattern">Thread pool</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Task-based parallelism </td> 
           <td> <span class="unknown-node">{{partial}}</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Semaphore (programming)">Semaphores</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Monitor (synchronization)">Monitors</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Thread local variables </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span>; ThreadStaticAttribute </p> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Native interoperability </h3> 
       <div class="section-body"> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> Native interoperability </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> <a href="Cross-language interoperability">Cross-language interoperability</a> </td> 
           <td> <span class="unknown-node">{{no}}</span> (only with <a href="CORBA">CORBA</a> or <a href="JNI">JNI</a>)<span class="unknown-node">&lt;ref .../&gt;</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span>; C# was designed for it<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> External/native methods </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Marshalling (computer science)">Marshalling</a> </td> 
           <td> <span class="unknown-node">{{no|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span>; metadata controlled </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Pointer (computer programming)">Pointers</a> and arithmetics </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Native types </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Fixed-size buffers </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Explicit stack allocation </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> Address-of </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Object pinning#Moving vs. non-moving">Object pinning (fix variable to address)</a> </td> 
           <td> <span class="unknown-node">{{no}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <p> The <a href="Java Native Interface">Java Native Interface</a> (JNI) feature allows Java programs to call non-Java code. However, JNI does require the code being called to follow several conventions and imposes restrictions on types and names used. This means that an extra adaption layer between legacy code and Java is often needed. This adaption code must be coded in a non-Java language, often C or C++. <a href="Java Native Access">Java Native Access</a> (JNA) allows easier calling of native code that only requires writing Java code, but comes at a performance cost. </p> 
        <p> In addition, third party <a href="Library (computing)">libraries</a> provide for Java-<a href="Component Object Model">COM</a> bridging, e.g. <a href="http://jacob-project.sourceforge.net/">JACOB</a> (<a href="Free software">free</a>), and <a href="http://j-integra.intrinsyc.com/products/com/">J-Integra for COM</a> (<a href="Proprietary software">proprietary</a>). </p> 
        <p> .NET Platform Invoke (<a href="Platform Invocation Services">P/Invoke</a>) offers the same capability by allowing calls from C# to what Microsoft refers to as <a href="Managed code">unmanaged code</a>. Through metadata attributes the programmer can control exactly how the parameters and results are <a href="Marshalling (computer science)">marshalled</a>, thus avoiding the need for extra adaption code. P/Invoke allows almost complete access to procedural APIs (such as Win32 or POSIX), but limited access to C++ class libraries. </p> 
        <p> In addition, .NET Framework also provides a .NET-COM bridge, allowing access to COM components as, if they were first-class .NET objects. </p> 
        <p> C# also allows the programmer to disable the normal type-checking and other safety features of the <a href="Common Language Runtime">CLR</a>, which then enables the use of <a href="Pointer (computer programming)">pointer variables</a>. When using this feature, the programmer must mark the code using the <code>unsafe</code> keyword. JNI, P/Invoke, and &quot;unsafe&quot; code are equally risky features, exposing possible security holes and application instability. An advantage of unsafe, managed code over P/Invoke or JNI is that it allows the programmer to continue to work in the familiar C# environment to accomplish some tasks that otherwise would require calling out to unmanaged code. An assembly (program or library) using unsafe code must be compiled with a special switch and will be marked as such. This enables runtime environments to take special precautions before executing potentially harmful code. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Platform support </h3> 
       <div class="section-body"> 
        <table class="wikitable" style="width:80%;"> 
         <tbody>
          <tr> 
           <th style="width:40%;"> Platform support </th> 
           <th style="width:30%;"> Java </th> 
           <th style="width:30%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> <a href="Linux">Linux</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Mac OS X">Mac OS X</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Solaris (operating system)">Solaris</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="FreeBSD">FreeBSD</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="IBM AIX">AIX</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{partial}}</span>? </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="iOS (Apple)">iOS</a> </td> 
           <td> <span class="unknown-node">{{no|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Microsoft Windows">Windows</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Windows Mobile">Windows Mobile</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Windows Phone">Windows Phone</a> </td> 
           <td> <span class="unknown-node">{{no|...}}</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </td> 
           <td> <p> <span class="unknown-node">{{yes}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Android (operating system)">Android</a> </td> 
           <td> <span class="unknown-node">{{yes|...}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Java ME">Feature phones</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{no}}</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="Symbian">Symbian</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{partial|...}}</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <a href="BlackBerry OS">Blackberry</a> </td> 
           <td> <span class="unknown-node">{{yes}}</span> </td> 
           <td> <p> <span class="unknown-node">{{yes|...}}</span><span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Syntax </h3> 
       <div class="section-body"> 
        <p> Both languages are considered &quot;curly brace&quot; languages in the C/C++ family. Overall the syntaxes of the languages are very similar. The syntax at the statement and expression level is almost identical with obvious inspiration from the C/C++ tradition. At type definition level (classes and interfaces) some minor differences exist. Java is explicit about extending classes and implementing interfaces, while C# infers this from the kind of types a new class/interface derives from. </p> 
        <p> C# supports more features than Java, which to some extent is also evident in the syntax that specifies more keywords and more grammar rules than Java. </p> 
        <div class="section"> 
         <h4> Keywords and backward compatibility </h4> 
         <div class="section-body"> 
          <p> As the languages evolved, the language designers for both languages have faced situations where they wanted to extend the languages with new keywords or syntax. New keywords in particular may break existing code at source level, i.e. older code may no longer compile, if presented to a compiler for a later version of the language. Language designers are keen to avoid such regressions. The designers of the two languages have been following different paths when addressing this problem. </p> 
          <p> Java language designers have avoided new keywords as much as possible, preferring instead to introduce new syntactic constructs that were not legal before or to reuse existing keywords in new contexts. This way they didn't jeopardize backward compatibility. An example of the former can be found in how the <code>for</code> loop was extended to accept iterable types. An example of the latter can be found in how the <code>extends</code> and (especially) the <code>super</code> keywords were reused for specifying type bounds when generics were introduced in Java 1.5. At one time (Java 1.4) a new keyword <code>assert</code> was introduced that was not reserved as a keyword before. This had the potential to render previously valid code invalid, if for instance the code used <code>assert</code> as an identifier. The designers chose to address this problem with a four step solution: 1) Introducing a compiler switch that indicates if Java 1.4 or later should be used, 2) Only marking <code>assert</code> as a keyword when compiling as Java 1.4 and later, 3) Defaulting to 1.3 to avoid rendering previous (non 1.4 aware code) invalid and 4) Issue warnings, if the keyword is used in Java 1.3 mode, in order to allow the developers to change the code. </p> 
          <p> C# language designers have introduced several new keywords since the first version. However, instead of defining these keywords as <i>global</i> keywords, they define them as <i>context sensitive</i> keywords. This means that even when they introduced (among others) the <code>partial</code> and <code>yield</code> keywords in C# 2.0, the use of those words as identifiers is still valid as there is no clash possible between the use as keyword and the use as identifier, given the context. Thus, the present C# syntax is fully backward compatible with source code written for any previous version without specifying the language version to be used. </p> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
    <div class="section"> 
     <h2> Notation and special features </h2> 
     <div class="section-body"> 
      <div class="section"> 
       <h3> Special feature keywords </h3> 
       <div class="section-body"> 
        <table class="wikitable"> 
         <tbody>
          <tr> 
           <th> keyword </th> 
           <th> <p> feature, example usage </p> </th> 
          </tr> 
          <tr> 
           <td> <code>checked</code>, <code>unchecked</code> </td> 
           <td> <p> In C#, <code>checked</code> statement blocks or expressions can enable run-time checking for <a href="arithmetic overflow">arithmetic overflow</a>.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <code>get</code>, <code>set</code> </td> 
           <td> <p> C# implements <a href="property (computer science)">properties</a> as part of the language syntax with their optional corresponding <code>get</code> and <code>set</code> accessors, as an alternative for the <a href="accessor method">accessor methods</a> used in Java, which is not a language feature but a coding-pattern based on method name conventions. </p> </td> 
          </tr> 
          <tr> 
           <td> <code>goto</code> </td> 
           <td> <p> C# supports the <code><a href="goto (command)">goto</a></code> keyword. This can occasionally be useful, for example for implementing <a href="finite state machine">finite state machines</a> or for <a href="Code generation (compiler)">generated code</a>, but the use of a more structured method of <a href="control flow">control flow</a> is usually recommended (see <a href="Goto#Usage">criticism of the goto statement</a>). Java does not support the <code>goto</code> statement (but <code>goto</code> is a reserved word). However, Java does support labeled <code>break</code> and <code>continue</code> statements, which in certain situations can be used when a <code>goto</code> statement might otherwise be used. </p> <p> <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> switch(color) { </p> <pre>   case Color.Blue:
        Console.WriteLine(&quot;Color is blue&quot;); break;
   case Color.DarkBlue:
        Console.WriteLine(&quot;Color is dark&quot;);
        goto case Color.Blue;
   // ...
</pre> <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <code>lock</code> </td> 
           <td> <p> In C#, the <code>lock</code> keyword is a shorthand for synchronizing access to a block of code across threads (using a <code>Monitor</code>), wrapped in a <code>try</code> ? <code>finally</code> block. </p> </td> 
          </tr> 
          <tr> 
           <td> <code>out</code>, <code>ref</code> </td> 
           <td> <p> C# has support for output and reference <a href="parameter (computer science)">parameters</a>. These allow returning multiple output values from a method, or passing values by reference. </p> </td> 
          </tr> 
          <tr> 
           <td> <code>strictfp</code> </td> 
           <td> <p> Java uses <code><a href="strictfp">strictfp</a></code> to guarantee the results of floating point operations remain the same across platforms. </p> </td> 
          </tr> 
          <tr> 
           <td> <code>switch</code> </td> 
           <td> <p> In C#, the <a href="switch statement">switch statement</a> also operates on strings and longs. Fallthrough is allowed for empty statements and possible via 'goto case' for statements containing code. Java's switch statement does not operate on strings (before <a href="Java 7">Java 7</a>) nor <code>long</code> primitive type but falls through for all statements (excluding those with '<code>break</code>').<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <code>synchronized</code> </td> 
           <td> <p> In Java, the <code>synchronized</code> keyword is a shorthand for synchronizing access to a block of code across threads (using a <code>Monitor</code>), wrapped in a <code>try</code> ? <code>finally</code> block. </p> </td> 
          </tr> 
          <tr> 
           <td> <code>throws</code> </td> 
           <td> <p> Java requires every method to declare the checked exceptions or superclasses of the checked exceptions that it can throw. Any method can also optionally declare the unchecked exception that it throws. C# has no such syntax. <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> public int readItem() throws java.io.IOException { </p> <pre>   // ...
</pre> <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td> <code>using</code> </td> 
           <td> <p> In C#, <code>using</code> causes the <code>Dispose</code> method (implemented via the <code>IDisposable</code> interface) of the object declared to be executed after the code block has run or when an exception is thrown within the code block. <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> // Create a small file &quot;test.txt&quot;, write a string, // ... and close it (even if an exception occurs) using (StreamWriter file = new StreamWriter(&quot;test.txt&quot;)) { </p> <pre>   file.Write(&quot;test&quot;);
</pre> <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Numeric applications </h3> 
       <div class="section-body"> 
        <p> To adequately support applications in the field of mathematical and financial computation, several language features exist.<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> In this category, Java provides the <a href="strictfp">strictfp</a> keyword, which enables strict floating-point calculations for a region of code. This will ensure that calculations return exactly the same result on all platforms. C# provides no equivalent, but does provide the built-in <code>decimal</code> type which has higher accuracy than the Java/C# double (128 bits vs 64 bits). </p> 
        <p> The <span class="unknown-node">{{Javadoc:SE|...}}</span> and <span class="unknown-node">{{Javadoc:SE|...}}</span> types provided with Java allow arbitrary-precision representation of numbers. <span class="unknown-node">{{As of|...}}</span> the current stable release of the .NET framework (4.0) includes classes for manipulating arbitrary-precision integers and complex numbers (with operators overloaded for easy use so that C# BigInteger objects can be used just like any other primitive data type), but still the .NET Framework lacks classes to deal with arbitrary-precision floating point numbers (see <a href="Arbitrary-precision arithmetic#Arbitrary-precision software">software for arbitrary-precision arithmetic</a>). </p> 
        <p> C# can help mathematical applications with the <code>checked</code> and <code>unchecked</code> operators that allow the enabling or disabling of run-time checking for <a href="arithmetic overflow">arithmetic overflow</a> for a region of code. </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Language integrated query (LINQ) </h3> 
       <div class="section-body"> 
        <p> <span class="unknown-node">{{Further|...}}</span> </p> 
        <p> C#s <a href="LINQ">Language Integrated Query (LINQ)</a> is not really a single feature; rather it is a number of features designed to work together to allow for in-language querying capabilities. LINQ has emerged as one of the most distinguishing features between Java and C#<span class="unknown-node">{{Whom?|...}}</span>. </p> 
        <p> LINQ consists of the following features: </p> 
        <ul> 
         <li> Extension methods allow existing interfaces or classes to be extended with new methods. Implementations can be shared or an interface can have a dedicated implementation.</li> 
         <li> Lambdas allow for expression of criteria in a functional fashion.</li> 
         <li> Expression trees allow a specific implementation to capture a lambda as an <a href="abstract syntax tree">abstract syntax tree</a> rather than an executable block. This can be utilized by implementations to represent criteria in a different language, e.g. in the form of an <a href="Where (SQL)">SQL where clause</a> as is the case with e.g. <a href="Linq#LINQ to SQL (formerly called DLINQ)">Linq, LINQ to SQL</a>.</li> 
         <li> Anonymous types and type inference supports capturing and working with the result type of a query. A query may both join and project over query sources that may lead to a result type that cannot be named.</li> 
         <li> Query expressions to support a syntax familiar to <a href="SQL">SQL</a> users.</li> 
         <li> Nullable (lifted) types to allow for a better match with query providers that support nullable types, like e.g. <a href="SQL">SQL</a>.</li> 
        </ul> 
       </div> 
      </div> 
     </div> 
    </div> 
    <div class="section"> 
     <h2> Examples </h2> 
     <div class="section-body"> 
      <div class="section"> 
       <h3> Input/output </h3> 
       <div class="section-body"> 
        <p> Example illustrating how to copy text one line at a time from one file to another, using both languages. </p> 
        <table width="100%"> 
         <tbody>
          <tr> 
           <th width="50%"> <p> Java </p> </th> 
           <th width="50%"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td valign="top"> <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> import java.io.*; public class FileIOTest { </p> <pre>   public static void main(String... args) throws IOException {
       String string = null;
       try (
           BufferedReader br = new BufferedReader(
               new FileReader( new File(&quot;input.txt&quot;) ));
           BufferedWriter bw = new BufferedWriter(
               new FileWriter( new File(&quot;output.txt&quot;) ))
       ) {
           while ((string = br.readLine()) != null) 
               bw.write(string);
       }
   }
</pre> <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
           <td valign="top"> <p> <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> using System.IO; class FileIOTest { </p> <pre>   public static void Main(string[] args) 
   {
       var lines = File.ReadLines(&quot;input.txt&quot;);
       using ((IDisposable)lines) 
           File.WriteAllLines(&quot;output.txt&quot;, lines);
   }
</pre> <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td valign="top"> <p> Notes on the Java implementation: </p> 
            <ul> 
             <li> A <tt>BufferedReader</tt> is used because the program would read the input file one character at a time otherwise.</li> 
             <li> A try-with-resources block is used to ensure the streams are properly closed even in the case of abnormal termination</li> 
            </ul> </td> 
           <td valign="top"> <p> Notes on the C# implementation: </p> 
            <ul> 
             <li> The <tt>ReadLines</tt> method returns an enumerable object which upon enumeration will read the file one line at a time.</li> 
             <li> The <tt>WriteAllLines</tt> method takes an enumerable and retrieves a line at a time and writes it until the enumeration ends.</li> 
             <li> The underlying reader will automatically allocate a buffer, thus there is no need to explicitly introduce a buffered stream.</li> 
             <li> A <tt>using</tt> block is used to ensure that the input stream is properly closed in case of abnormal termination.</li> 
             <li> <tt>WriteAllLines</tt> automatically closes the output stream, also in the case of an abnormal termination.</li> 
            </ul> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Integration of library defined types </h3> 
       <div class="section-body"> 
        <p> C# allows library defined types to be integrated with existing types and operators by using custom implicit/explicit conversions and operator overloading as illustrated by the following example: </p> 
        <table style="width:100%;"> 
         <tbody>
          <tr> 
           <th style="width:50%;"> Java </th> 
           <th style="width:50%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> BigInteger bigNumber = </p> <pre>  new BigInteger(&quot;123456789012345678901234567890&quot;);
</pre> <p> BigInteger answer = bigNumber.multiply(new BigInteger(&quot;42&quot;)); BigInteger square = bigNumber.multiply(bigNumber); BigInteger sum = bigNumber.add(bigNumber); <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
           <td> <p> <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> var bigNumber = </p> <pre>  BigInteger.Parse(&quot;123456789012345678901234567890&quot;);
</pre> <p> var answer = bigNumber * 42; var square = bigNumber * bigNumber; var sum = bigNumber + bigNumber; <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> C# delegates and equivalent Java constructs </h3> 
       <div class="section-body"> 
        <table style="width:100%;"> 
         <tbody>
          <tr> 
           <th style="width:50%;"> Java </th> 
           <th style="width:50%;"> <p> C# </p> </th> 
          </tr> 
          <tr valign="top"> 
           <td> <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> </p> <pre>   // define a common interface for all invokeable objects
   // (will use the wrapper pattern)
   interface Invokeable {
       boolean invoke(String arg);
   }
</pre> <pre>   // a target class
   class Target {
       public boolean targetMethod(String arg) {
           // do something
           return true;
       }
   }
</pre> <pre>   // usage
   void doSomething() {
</pre> <pre>       // construct a target with the target method
       final Target target = new Target();
</pre> <pre>       // wrap the target
       Invokeable ivk = new Invokeable() {
           public boolean invoke(String arg) {
               return target.targetMethod(arg);
           }
       };
</pre> <pre>       // use the target through the wrapper
       boolean result = ivk.invoke(&quot;argumentstring&quot;);
   }
</pre> <p> <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
           <td> <p> <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> </p> <pre>   // a target class
   class Target
   {
       public bool TargetMethod(string arg)
       {
           // do something
           return true;
       }
   }
</pre> <pre>   // usage
   void DoSomething()
   {
       // construct a target with the target method
       var target = new Target();
</pre> <pre>       // capture the delegate for later invocation
       Func&lt;string, bool&gt; dlg = target.TargetMethod;
</pre> <pre>       // invoke the delegate
       bool result = dlg(&quot;argumentstring&quot;);
   }
</pre> <p> <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Type lifting </h3> 
       <div class="section-body"> 
        <table style="width:100%;"> 
         <tbody>
          <tr> 
           <th style="width:50%;"> Java </th> 
           <th style="width:50%;"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td> <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> Integer a = 42; Integer b = null; </p> <p> // This will generate a runtime NullPointerException, // because it attempts to unbox the null value. Integer c = a * b; <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
           <td> <p> <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> int? a = 42; int? b = null; </p> <p> // c will receive the null value // because * is lifted and one of the operands are null int? c = a * b; <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Interoperability with dynamic languages </h3> 
       <div class="section-body"> 
        <p> This example illustrates how Java and C# can be used to create and invoke an instance of class which is implemented in another programming language. The &quot;Deepthought&quot; class is implemented using the <a href="Ruby (programming language)">Ruby programming language</a> and represents a simple calculator which will multiply two input values (<tt>a</tt> and <tt>b</tt>) when the <tt>Calculate</tt> method is invoked. </p> 
        <table width="100%" style="border:none"> 
         <tbody>
          <tr> 
           <th width="50%"> <p> Java </p> </th> 
           <th width="50%"> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td valign="top"> <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> // initialize the engine </p> <p> ScriptEngineManager factory = new ScriptEngineManager(); ScriptEngine engine = factory.getEngineByName(&quot;jruby&quot;); Invocable invocable = (Invocable) engine; </p> <p> FileReader fr = new FileReader(&quot;Deepthought.rb&quot;); engine.eval(fr); <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
           <td valign="top"> <p> <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> // initialize the engine </p> <p> var runtime = ScriptRuntime.CreateFromConfiguration(); dynamic globals = runtime.Globals; </p> <p> runtime.ExecuteFile(&quot;Deepthought.rb&quot;); <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
          </tr> 
          <tr> 
           <td valign="top"> <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> // create a new instance of &quot;Deepthought&quot; calculator Object calcClass = engine.eval(&quot;Deepthought&quot;); Object calc = invocable.invokeMethod(calcClass, &quot;new&quot;); </p> <p> // set calculator input values invocable.invokeMethod(calc, &quot;a=&quot;, 6); invocable.invokeMethod(calc, &quot;b=&quot;, 7); </p> <p> // calculate the result Object answer = invocable.invokeMethod(calc, &quot;Calculate&quot;); </p> <p> <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
           <td valign="top"> <p> <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> // create a new instance of &quot;Deepthought&quot; calculator var calc = globals.Deepthought.@new(); </p> <p> // set calculator input values calc.a = 6; calc.b = 7; </p> <p> // calculate the result var answer = calc.Calculate(); <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
          </tr> 
          <tr valign="top"> 
           <td> <p> Notes for the Java implementation: </p> 
            <ul> 
             <li> Ruby accessors names are generated from the attribute name with a <code>=</code> suffix. When assigning values, Java developers must use the Ruby accessor method name.</li> 
             <li> Dynamic objects from a foreign language are not first-class objects in that they must be manipulated through an API.</li> 
            </ul> </td> 
           <td> <p> Notes for the C# implementation: </p> 
            <ul> 
             <li> Objects returned from properties or methods of <code>dynamic</code> objects are themselves of <code>dynamic</code> type. When type inference (the <code>var</code> keyword) is used, the variables calc and answer are inferred dynamic/late-bound.</li> 
             <li> Dynamic, late-bounds objects are first-class citizens that can be manipulated using C# syntax even though they have been created by an external language.</li> 
             <li><code>new</code> is a reserved word. The <code>@</code> prefix allows keywords to be used as identifiers.</li> 
            </ul> </td> 
           <td> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Pass by reference </h3> 
       <div class="section-body"> 
        <table width="100%" style="border:none"> 
         <tbody>
          <tr> 
           <th width="50%"> Java </th> 
           <th width="50%"> <p> C# </p> </th> 
          </tr> 
          <tr valign="top"> 
           <td> <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span>public class PassByRefTest { </p> <pre>   public static void changeMe(String string) {
       string = &quot;Changed&quot;;
   }
   
   public static void swap(int x, int y) {
       int temp = x;
       
       x = y;
       y = temp;
   }
   
   public static void main(String[] args) {
       int a = 5, b = 20;
       String s = &quot;still unchanged&quot;;
       
       swap(a, b);
       changeMe(s);
       
       System.out.println( &quot;a = &quot; + a + &quot;, &quot; + 
                           &quot;b = &quot; + b + &quot;, &quot; +
                           &quot;s = &quot; + s );
   }
</pre> <p> }<span class="unknown-node">&lt;/source&gt;</span> || <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span>class PassByRefTest { </p> <pre>   public static void ChangeMe(out string s) {
       s = &quot;Changed&quot;; 
   }
</pre> <pre>   public static void Swap(ref int x, ref int y) {
       int temp = x;
</pre> <pre>       x = y;
       y = temp;
   }
</pre> <pre>   public static void Main(string[] args) {
       int a = 5, b = 10; 
       string s; 
</pre> <pre>       Swap(ref a, ref b); 
       ChangeMe(out s); 
</pre> <pre>       System.Console.WriteLine(&quot;a = &quot; + a + &quot;, &quot; +
                                &quot;b = &quot; + b + &quot;, &quot; +
                                &quot;s = &quot; + s);
   }
</pre> <p> }<span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
          </tr> 
          <tr valign="top"> 
           <td> <code>a = 5, b = 20, s = still unchanged</code> </td> 
           <td> <p> <code>a := 10, b := 5, s = Changed</code> </p> </td> 
          </tr> 
         </tbody>
        </table> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> Fibonacci sequence </h3> 
       <div class="section-body"> 
        <p> This example illustrates how the <a href="Fibonacci sequence">Fibonacci sequence</a> can be implemented using the two languages. The C# version takes advantage of C# <a href="#Generator methods">generator methods</a>. </p> 
        <table width="100%" style="border:none"> 
         <tbody>
          <tr> 
           <th> <p> Java </p> </th> 
           <th> <p> C# </p> </th> 
          </tr> 
          <tr> 
           <td width="50%"> <p> <span class="unknown-node">&lt;source lang=&quot;Java&quot;&gt;</span> public class Fibonacci implements Iterable<span class="unknown-node">&lt;Integer&gt;</span> { </p> <pre>   public Iterator<span class="unknown-node">&lt;Integer&gt;</span> iterator() {
       return new Iterator<span class="unknown-node">&lt;Integer&gt;</span>() {
</pre> <pre>           private int a = 0;
           private int b = 1;
</pre> <pre>           public boolean hasNext() {
               return true; // infinite sequence
           }
</pre> <pre>           public Integer next() {
               int tmp = a;
               a = b;
               b = a + tmp;
               return tmp;
           }
</pre> <pre>           public void remove() {
               throw new UnsupportedOperationException
                   (&quot;Not supported on the Fibonacci sequence.&quot;);
           }
       };
   }
</pre> <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
           <td width="50%" valign="top"> <p> <span class="unknown-node">&lt;source lang=&quot;CSharp&quot;&gt;</span> public static IEnumerable<span class="unknown-node">&lt;int&gt;</span> Fibonacci() { </p> <pre>   int a = 0;
   int b = 1;
</pre> <pre>   while (true) 
   {
       yield return a;
       a += b;
       yield return b;
       b += a;
   }
</pre> <p> } <span class="unknown-node">&lt;/source&gt;</span> </p> </td> 
          </tr> 
         </tbody>
        </table> 
        <p> The Java version defines a <tt>Fibonacci</tt> class which represents the infinite sequence. The class implements a method which returns an <a href="#anonymous class">#anonymous class</a> based on the <tt>Iterator</tt> interface. This interface allows client code to repeatedly call the <tt>hasNext()</tt> method to inquire whether there are more numbers. As the Fibonacci sequence is infinite this method simply returns true (there's always next number). The <tt>next()</tt> method calculates and returns the next number. As the interface formally also allows the client to request removal of numbers, this methods also has to be implemented. However, in this case removal of numbers is not supported as the Fibonacci sequence is a mathematically defined sequence. </p> 
        <p> The C# version defines a method as opposed to a class. The method returns an <tt>IEnumerable</tt> which makes it eligible for being implemented as a <a href="#Generator methods">generator method</a> by using the <tt>yield</tt> syntax. The fact that the Fibonacci sequence is an infinite sequence is represented by an infinite loop. Inside the loop the numbers are &quot;yielded&quot;. A <tt>yield return</tt> statement returns the next number in the sequence but will continue the execution at the following statement when (and if) the client requests the next number. </p> 
       </div> 
      </div> 
     </div> 
    </div> 
    <div class="section"> 
     <h2> Runtime environments </h2> 
     <div class="section-body"> 
      <p> Java (the programming language) is designed to execute on the Java platform via the <a href="Java Runtime Environment">Java Runtime Environment</a> (JRE). The Java platform includes the <a href="Java Virtual Machine">Java Virtual Machine</a> (JVM) as well as a common set of libraries. The JRE was originally designed to support interpreted execution with final compilation as an option. Most JRE environments execute fully or at least partially compiled programs, possibly with <a href="adaptive optimization">adaptive optimization</a>. The Java compiler produces <a href="Java bytecode">Java bytecode</a>. Upon execution the bytecode is loaded by the Java runtime and either interpreted directly or compiled to machine instructions and then executed. <span class="unknown-node">{{Further|...}}</span> </p> 
      <p> C# is designed to execute on the <a href="Common Language Runtime">Common Language Runtime</a> (CLR). The CLR is designed to execute fully compiled code. The C# compiler produces <a href="Common Intermediate Language">Common Intermediate Language</a> instructions. Upon execution the runtime loads this code and compiles to machine instructions on the target architecture. <span class="unknown-node">{{Further|...}}</span> </p> 
      <div class="section"> 
       <h3> Speed/performance comparison </h3> 
       <div class="section-body"> 
        <p> Comparing language speed is tricky. It depends on the virtual machine and the environment used. It can also depend on whether the benchmark code was written in an idiomatic or an optimised style. </p> 
        <p> A 2012 benchmark test of a Java 7 JRE and the Mono C# runtime (version 3.0), found that a Java 7 JRE tended to use more memory and could be up to 6 times faster or half the speed of the mono Mono C# runtime when tested in a Linux environment, though the two were largely comparable in most tests. <span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
       </div> 
      </div> 
     </div> 
    </div> 
    <div class="section"> 
     <h2> Language history and evolution </h2> 
     <div class="section-body"> 
      <div class="section"> 
       <h3> Java </h3> 
       <div class="section-body"> 
        <p> <span class="unknown-node">{{Original research |...}}</span> <span class="unknown-node">{{Weasel |...}}</span> <span class="unknown-node">{{relevance |...}}</span> </p> 
        <p> Java (first released in 1995) is older than C# (first released 2002): it has been implemented and freely distributed, as the Java Runtime Environment (JRE) on a much wider variety of computer-vendor platforms. By contrast, C# and the .NET framework (Microsoft's equivalent of JRE) are primarily based on <a href="Microsoft Windows">Microsoft Windows</a>-based platforms. (Note: though the laudable <a href="Mono (software)">Mono</a> project has made C# and .NET available on Linux since 2004, this open-source effort is independent of, and not tightly coordinated with, Microsoft's development efforts. This lead has translated to a larger user base,<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> a larger number of third-party libraries<span class="unknown-node">{{citation needed|...}}</span> (many of them open-source), and wider use in education and many modern branches of computer science<span class="unknown-node">{{citation needed|...}}</span>. </p> 
        <p> Compared to C#, Java versions have evolved more slowly with respect to features. This conservative approach to language change has consequences that may be both negative (slower evolution to meet perceived programmer needs) and positive (less risk of prematurely adopting approaches that might later prove to be dead-ends). It is now fair to say, however, that while C# was originally designed to be highly similar to Java in many respects, recent versions of Java (notably version 5.0) have in turn implemented ideas originally implemented in C#, such as the <a href="foreach">foreach</a> construct, <a href="autoboxing">autoboxing</a>, methods with variable number of parameters (<a href="varargs">varargs</a>), <a href="enumerated type">enumerated types</a>, and <a href="annotation">annotations</a>.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
       </div> 
      </div> 
      <div class="section"> 
       <h3> C# </h3> 
       <div class="section-body"> 
        <p> Before creating C#, Microsoft had implemented a modified version of Java, called <a href="Visual J++">J++</a> and a modified version of the <a href="Java Runtime Environment">Java Runtime Environment</a> (JRE). In 1997, Sun Microsystems sued Microsoft, claiming that Microsoft had added new features in a manner that contravened Sun's standards and conventions for Java platform neutrality, and which features therefore violated the license agreement between Microsoft and Sun. The suit was settled in 2001: Microsoft agreed to pay Sun $20 million and gradually phase out the Microsoft JRE over seven years.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
        <p> At time of the settlement Microsoft had already revealed the first version of C# which was based on <a href=".NET Framework">.NET</a> as opposed to the JRE. While developing C#, <a href="Anders Hejlsberg">Anders Hejlsberg</a>'s team at Microsoft studied a number of existing languages including <a href="C++">C++</a>, Java, <a href="Modula-2">Modula-2</a>, <a href="C (programming language)">C</a> and <a href="Smalltalk">Smalltalk</a>.<span class="unknown-node">&lt;ref ...&gt;...&lt;/ref&gt;</span> </p> 
        <p> The first version of C# implemented roughly the same features as Java although it was deliberately closer to C++ in syntax.<span class="unknown-node">&lt;ref .../&gt;</span> The most notable differences was the C# support for delegates and events, metadata attributes/annotations and the way programs could call into the underlying platform. C# delegates and events supported the same use cases as the Java anonymous and local classes, i.e. support for event-based programming and <a href="callbacks">callbacks</a>. When calling into the underlying operating system, C# P/Invoke relied on marshalling controlled by metadata attributes as opposed to the external glue code required by the equivalent <a href="JNI">JNI</a> in Java. </p> 
        <p> C# 2.0 introduced generic types into the language (at roughly the same time generics also appeared in Java). C# 2.0 also introduced closures in the form of anonymous methods (an inline <tt>delegate</tt> syntax) as well as generator methods, partial classes and -methods. </p> 
        <p> C# 3.0 added <a href="SQL">SQL</a>-like <a href="Language Integrated Query">language integrated queries</a> suited for querying data from <a href="Collection class">collections</a>, <a href="database">databases</a> or <a href="XML">XML</a> documents, building upon general-purpose language features, including <a href="lambda expression">lambda expressions</a> and <a href="extension method">extension methods</a>, to allow queries to be expressed and optimized for user types. </p> 
        <p> C# 4 introduced features from dynamic scripting languages such as <a href="Ruby programming language">Ruby</a> and <a href="Python programming language">Python</a>.<span class="unknown-node">&lt;ref&gt;...&lt;/ref&gt;</span> </p> 
        <p> C# 5 focused on improving language support for asynchronous and parallel/concurrent programming by making asynchronous continuations a first-class language feature through the new <tt>async</tt> and <tt>await</tt> syntax. </p> 
       </div> 
      </div> 
     </div> 
    </div> 
    <div class="section"> 
     <h2> See also </h2> 
     <div class="section-body"> 
      <ul> 
       <li> <a href="Comparison of C sharp and Visual Basic .NET">Comparison of C# and VB.NET</a></li> 
       <li> <a href="Comparison of Java and C++">Comparison of Java and C++</a></li> 
       <li> <a href="Java (programming language)">Java programming language</a></li> 
       <li> <a href="Comparison of the Java and .NET platforms">Comparison of the Java and .NET platforms</a></li> 
      </ul> 
     </div> 
    </div> 
    <div class="section"> 
     <h2> References </h2> 
     <div class="section-body"> 
      <p> <span class="unknown-node">{{Reflist|...}}</span> </p> 
     </div> 
    </div> 
    <div class="section"> 
     <h2>External links</h2> 
     <div class="section-body"> 
      <ul> 
       <li> <a href="http://msdn.microsoft.com/en-us/gg715299.aspx">Moving to C# and the .NET Framework</a> at <a href="MSDN">MSDN</a></li> 
       <li> <a href="http://msdn.microsoft.com/en-us/library/ms836794.aspx">C# and Java: Comparing Programming Languages</a> at <a href="MSDN">MSDN</a></li> 
       <li> <a href="http://www.javacamp.org/javavscsharp/">Java vs. C# - Code for Code Comparison</a></li> 
       <li> <a href="http://www.osnews.com/story.php?news_id=5602">Nine Language Performance Round-up</a></li> 
       <li> <a href="Microsoft Developer Network">MSDN</a>: <a href="http://msdn.microsoft.com/en-us/library/ms228602.aspx">The C# Programming Language for Java Developers</a></li> 
       <li> <a href="http://www.ecma-international.org/publications/standards/Ecma-334.htm">Standard ECMA-334 C# Language specification</a></li> 
       <li> <a href="http://java.sun.com/docs/books/jls/">Java Language Specification (Sun)</a></li> 
      </ul> 
      <p> <span class="unknown-node">{{DotNET}}</span> <span class="unknown-node">{{Java (Sun)}}</span> </p> 
      <p> <span class="unknown-node">{{Use dmy dates |...}}</span> </p> 
      <p> <span class="unknown-node">{{DEFAULTSORT:Comparison Of Java And C Sharp}}</span> </p> 
      <p> <a href="Category:Programming language comparisons">C Sharp and Java</a> <a href="Category:Java programming language">Category:Java programming language</a> <a href="Category:C programming language family">Category:C programming language family</a> </p> 
     </div> 
    </div> 
   </div> 
  </div>    
 </body>
</html>