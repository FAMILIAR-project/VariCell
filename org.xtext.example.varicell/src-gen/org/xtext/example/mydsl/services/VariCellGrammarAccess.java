/*
* generated by Xtext
*/

package org.xtext.example.mydsl.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class VariCellGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class SToFMModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SToFMModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportViewsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportViewsImportViewsParserRuleCall_0_0 = (RuleCall)cImportViewsAssignment_0.eContents().get(0);
		private final Assignment cSplNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSplNameSPLNameParserRuleCall_1_0 = (RuleCall)cSplNameAssignment_1.eContents().get(0);
		private final Assignment cSchemaAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSchemaStructuringInformationParserRuleCall_2_0 = (RuleCall)cSchemaAssignment_2.eContents().get(0);
		private final Assignment cDefaultAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDefaultDefaultParserRuleCall_3_0 = (RuleCall)cDefaultAssignment_3.eContents().get(0);
		private final Assignment cScopingAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cScopingScopingViewParserRuleCall_4_0 = (RuleCall)cScopingAssignment_4.eContents().get(0);
		
		////"A domain-specific language can parameterize command line input".
		////OK, let us start with an DSL 
		////for extracting feature models from sources (e.g., semi-structured products specification)
		//SToFMModel:
		//	importViews= // a set of views
		//	ImportViews splName= // aka name of the integrated view aka root feature name in the resulting feature model
		//	SPLName // e.g., relationship between views
		//	schema=StructuringInformation? // default interpretation of data for *all* views
		//	default=Default? // the interpretation can be overriden in each view
		//	scoping+=ScopingView*;
		public ParserRule getRule() { return rule; }

		//importViews= // a set of views
		//ImportViews splName= // aka name of the integrated view aka root feature name in the resulting feature model
		//SPLName // e.g., relationship between views
		//schema=StructuringInformation? // default interpretation of data for *all* views
		//default=Default? // the interpretation can be overriden in each view
		//scoping+=ScopingView*
		public Group getGroup() { return cGroup; }

		//importViews= // a set of views
		//ImportViews
		public Assignment getImportViewsAssignment_0() { return cImportViewsAssignment_0; }

		//// a set of views
		//ImportViews
		public RuleCall getImportViewsImportViewsParserRuleCall_0_0() { return cImportViewsImportViewsParserRuleCall_0_0; }

		//splName= // aka name of the integrated view aka root feature name in the resulting feature model
		//SPLName
		public Assignment getSplNameAssignment_1() { return cSplNameAssignment_1; }

		//// aka name of the integrated view aka root feature name in the resulting feature model
		//SPLName
		public RuleCall getSplNameSPLNameParserRuleCall_1_0() { return cSplNameSPLNameParserRuleCall_1_0; }

		//// e.g., relationship between views
		//schema=StructuringInformation?
		public Assignment getSchemaAssignment_2() { return cSchemaAssignment_2; }

		//StructuringInformation
		public RuleCall getSchemaStructuringInformationParserRuleCall_2_0() { return cSchemaStructuringInformationParserRuleCall_2_0; }

		//// default interpretation of data for *all* views
		//default=Default?
		public Assignment getDefaultAssignment_3() { return cDefaultAssignment_3; }

		//Default
		public RuleCall getDefaultDefaultParserRuleCall_3_0() { return cDefaultDefaultParserRuleCall_3_0; }

		//// the interpretation can be overriden in each view
		//scoping+=ScopingView*
		public Assignment getScopingAssignment_4() { return cScopingAssignment_4; }

		//ScopingView
		public RuleCall getScopingScopingViewParserRuleCall_4_0() { return cScopingScopingViewParserRuleCall_4_0; }
	}

	public class ImportViewsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ImportViews");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cViewsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cViewsDataViewParserRuleCall_1_0 = (RuleCall)cViewsAssignment_1.eContents().get(0);
		
		//ImportViews:
		//	"import:" views+=DataView+;
		public ParserRule getRule() { return rule; }

		//"import:" views+=DataView+
		public Group getGroup() { return cGroup; }

		//"import:"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//views+=DataView+
		public Assignment getViewsAssignment_1() { return cViewsAssignment_1; }

		//DataView
		public RuleCall getViewsDataViewParserRuleCall_1_0() { return cViewsDataViewParserRuleCall_1_0; }
	}

	public class DataViewElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DataView");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFileAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFileSTRINGTerminalRuleCall_0_0 = (RuleCall)cFileAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cAsKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cViewnameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cViewnameIDTerminalRuleCall_1_1_0 = (RuleCall)cViewnameAssignment_1_1.eContents().get(0);
		
		//// TODO: by default, the name of each view is the name of the file
		//DataView:
		//	file=STRING ("as" viewname=ID)?;
		public ParserRule getRule() { return rule; }

		//file=STRING ("as" viewname=ID)?
		public Group getGroup() { return cGroup; }

		//file=STRING
		public Assignment getFileAssignment_0() { return cFileAssignment_0; }

		//STRING
		public RuleCall getFileSTRINGTerminalRuleCall_0_0() { return cFileSTRINGTerminalRuleCall_0_0; }

		//("as" viewname=ID)?
		public Group getGroup_1() { return cGroup_1; }

		//"as"
		public Keyword getAsKeyword_1_0() { return cAsKeyword_1_0; }

		//viewname=ID
		public Assignment getViewnameAssignment_1_1() { return cViewnameAssignment_1_1; }

		//ID
		public RuleCall getViewnameIDTerminalRuleCall_1_1_0() { return cViewnameIDTerminalRuleCall_1_1_0; }
	}

	public class SPLNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SPLName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNameKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_1_0_1 = (RuleCall)cNameAlternatives_1_0.eContents().get(1);
		
		//// basically, root name
		//SPLName:
		//	"name:" name=(STRING | ID);
		public ParserRule getRule() { return rule; }

		//"name:" name=(STRING | ID)
		public Group getGroup() { return cGroup; }

		//"name:"
		public Keyword getNameKeyword_0() { return cNameKeyword_0; }

		//name=(STRING | ID)
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//STRING | ID
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0_0() { return cNameSTRINGTerminalRuleCall_1_0_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_1() { return cNameIDTerminalRuleCall_1_0_1; }
	}

	public class StructuringInformationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StructuringInformation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStructuringInformationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cStructureKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRelationsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRelationsItemRelationParserRuleCall_2_0 = (RuleCall)cRelationsAssignment_2.eContents().get(0);
		private final Assignment cAbstractAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAbstractItemGeneralizationParserRuleCall_3_0 = (RuleCall)cAbstractAssignment_3.eContents().get(0);
		private final Assignment cMpAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cMpItemMappingParserRuleCall_4_0 = (RuleCall)cMpAssignment_4.eContents().get(0);
		
		/// *
		//Wikipedia:
		//A hierarchy is an arrangement of items (objects, names, values, categories, etc.) 
		//in which the items are represented as being "above," "below," or "at the same level as" one another. 
		//Here: items are views/(features within a view) 
		//// by default, all views (resp. features within a view) are at the same level, below the high-level concept (e.g., SPL name or view name)
		//TODO: I would say that even features in a specific view can be hierarchycally organize
		// * / StructuringInformation:
		//	{StructuringInformation} "structure:" relations+=ItemRelation* abstract+=ItemGeneralization* mp+=ItemMapping*;
		public ParserRule getRule() { return rule; }

		//{StructuringInformation} "structure:" relations+=ItemRelation* abstract+=ItemGeneralization* mp+=ItemMapping*
		public Group getGroup() { return cGroup; }

		//{StructuringInformation}
		public Action getStructuringInformationAction_0() { return cStructuringInformationAction_0; }

		//"structure:"
		public Keyword getStructureKeyword_1() { return cStructureKeyword_1; }

		//relations+=ItemRelation*
		public Assignment getRelationsAssignment_2() { return cRelationsAssignment_2; }

		//ItemRelation
		public RuleCall getRelationsItemRelationParserRuleCall_2_0() { return cRelationsItemRelationParserRuleCall_2_0; }

		//abstract+=ItemGeneralization*
		public Assignment getAbstractAssignment_3() { return cAbstractAssignment_3; }

		//ItemGeneralization
		public RuleCall getAbstractItemGeneralizationParserRuleCall_3_0() { return cAbstractItemGeneralizationParserRuleCall_3_0; }

		//mp+=ItemMapping*
		public Assignment getMpAssignment_4() { return cMpAssignment_4; }

		//ItemMapping
		public RuleCall getMpItemMappingParserRuleCall_4_0() { return cMpItemMappingParserRuleCall_4_0; }
	}

	public class ItemRelationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ItemRelation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cView1Assignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cView1Alternatives_0_0 = (Alternatives)cView1Assignment_0.eContents().get(0);
		private final RuleCall cView1IDTerminalRuleCall_0_0_0 = (RuleCall)cView1Alternatives_0_0.eContents().get(0);
		private final RuleCall cView1STRINGTerminalRuleCall_0_0_1 = (RuleCall)cView1Alternatives_0_0.eContents().get(1);
		private final Assignment cRelAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRelKindRelationEnumRuleCall_1_0 = (RuleCall)cRelAssignment_1.eContents().get(0);
		private final Assignment cView2Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cView2Alternatives_2_0 = (Alternatives)cView2Assignment_2.eContents().get(0);
		private final RuleCall cView2IDTerminalRuleCall_2_0_0 = (RuleCall)cView2Alternatives_2_0.eContents().get(0);
		private final RuleCall cView2STRINGTerminalRuleCall_2_0_1 = (RuleCall)cView2Alternatives_2_0.eContents().get(1);
		
		//// basically, a parent-child hierarchy
		//ItemRelation:
		//	view1=(ID | STRING) rel=KindRelation view2=(ID | STRING);
		public ParserRule getRule() { return rule; }

		//view1=(ID | STRING) rel=KindRelation view2=(ID | STRING)
		public Group getGroup() { return cGroup; }

		//view1=(ID | STRING)
		public Assignment getView1Assignment_0() { return cView1Assignment_0; }

		//ID | STRING
		public Alternatives getView1Alternatives_0_0() { return cView1Alternatives_0_0; }

		//ID
		public RuleCall getView1IDTerminalRuleCall_0_0_0() { return cView1IDTerminalRuleCall_0_0_0; }

		//STRING
		public RuleCall getView1STRINGTerminalRuleCall_0_0_1() { return cView1STRINGTerminalRuleCall_0_0_1; }

		//rel=KindRelation
		public Assignment getRelAssignment_1() { return cRelAssignment_1; }

		//KindRelation
		public RuleCall getRelKindRelationEnumRuleCall_1_0() { return cRelKindRelationEnumRuleCall_1_0; }

		//view2=(ID | STRING)
		public Assignment getView2Assignment_2() { return cView2Assignment_2; }

		//ID | STRING
		public Alternatives getView2Alternatives_2_0() { return cView2Alternatives_2_0; }

		//ID
		public RuleCall getView2IDTerminalRuleCall_2_0_0() { return cView2IDTerminalRuleCall_2_0_0; }

		//STRING
		public RuleCall getView2STRINGTerminalRuleCall_2_0_1() { return cView2STRINGTerminalRuleCall_2_0_1; }
	}

	public class ItemGeneralizationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ItemGeneralization");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cGeneralizeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cGeneralizeAlternatives_0_0 = (Alternatives)cGeneralizeAssignment_0.eContents().get(0);
		private final RuleCall cGeneralizeIDTerminalRuleCall_0_0_0 = (RuleCall)cGeneralizeAlternatives_0_0.eContents().get(0);
		private final RuleCall cGeneralizeSTRINGTerminalRuleCall_0_0_1 = (RuleCall)cGeneralizeAlternatives_0_0.eContents().get(1);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cGeneralizeKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cAbstractKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Assignment cViewsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cViewsAlternatives_2_0 = (Alternatives)cViewsAssignment_2.eContents().get(0);
		private final RuleCall cViewsIDTerminalRuleCall_2_0_0 = (RuleCall)cViewsAlternatives_2_0.eContents().get(0);
		private final RuleCall cViewsSTRINGTerminalRuleCall_2_0_1 = (RuleCall)cViewsAlternatives_2_0.eContents().get(1);
		
		////http://www.utexas.edu/its/archive/windows/database/datamodeling/dm/erintro.html: 
		////A generalization hierarchy is a form of abstraction that specifies that two or more entities that share common attributes can be generalized into a higher level entity type called a supertype or generic entity. 
		////The lower-level of entities become the subtype, or categories, to the supertype. Subtypes are dependent entities.
		//ItemGeneralization:
		//	generalize=(ID | STRING) ("generalize" | "abstract") views+=(ID | STRING)+;
		public ParserRule getRule() { return rule; }

		//generalize=(ID | STRING) ("generalize" | "abstract") views+=(ID | STRING)+
		public Group getGroup() { return cGroup; }

		//generalize=(ID | STRING)
		public Assignment getGeneralizeAssignment_0() { return cGeneralizeAssignment_0; }

		//ID | STRING
		public Alternatives getGeneralizeAlternatives_0_0() { return cGeneralizeAlternatives_0_0; }

		//ID
		public RuleCall getGeneralizeIDTerminalRuleCall_0_0_0() { return cGeneralizeIDTerminalRuleCall_0_0_0; }

		//STRING
		public RuleCall getGeneralizeSTRINGTerminalRuleCall_0_0_1() { return cGeneralizeSTRINGTerminalRuleCall_0_0_1; }

		//"generalize" | "abstract"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"generalize"
		public Keyword getGeneralizeKeyword_1_0() { return cGeneralizeKeyword_1_0; }

		//"abstract"
		public Keyword getAbstractKeyword_1_1() { return cAbstractKeyword_1_1; }

		//views+=(ID | STRING)+
		public Assignment getViewsAssignment_2() { return cViewsAssignment_2; }

		//ID | STRING
		public Alternatives getViewsAlternatives_2_0() { return cViewsAlternatives_2_0; }

		//ID
		public RuleCall getViewsIDTerminalRuleCall_2_0_0() { return cViewsIDTerminalRuleCall_2_0_0; }

		//STRING
		public RuleCall getViewsSTRINGTerminalRuleCall_2_0_1() { return cViewsSTRINGTerminalRuleCall_2_0_1; }
	}

	public class ItemMappingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ItemMapping");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cItemAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cItemAlternatives_0_0 = (Alternatives)cItemAssignment_0.eContents().get(0);
		private final RuleCall cItemIDTerminalRuleCall_0_0_0 = (RuleCall)cItemAlternatives_0_0.eContents().get(0);
		private final RuleCall cItemSTRINGTerminalRuleCall_0_0_1 = (RuleCall)cItemAlternatives_0_0.eContents().get(1);
		private final Assignment cActAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cActAlternatives_1_0 = (Alternatives)cActAssignment_1.eContents().get(0);
		private final Keyword cActReplaceKeyword_1_0_0 = (Keyword)cActAlternatives_1_0.eContents().get(0);
		private final Keyword cActCorrespondsToKeyword_1_0_1 = (Keyword)cActAlternatives_1_0.eContents().get(1);
		private final Assignment cPftsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPftsPredicateItemParserRuleCall_2_0 = (RuleCall)cPftsAssignment_2.eContents().get(0);
		
		//// item corresponds to ....
		//// e.g., SQL correspondsTo (MySQL or PostgreSQL or SQLite)
		//// I made a difference between replace and correspondsTo
		//// replace: pfts no longer appear in the resulting feature model whereas nfeature is added
		//// correspondsTo: nfeature is added in the resulting feature model as well as pfts 
		//// (nfeature is basically an optional feature (TODO: where in the hierarchy?) related to pfts features by propositional constraints)
		//ItemMapping:
		//	item=(ID | STRING) act=("replace" | "correspondsTo") pfts=PredicateItem;
		public ParserRule getRule() { return rule; }

		//item=(ID | STRING) act=("replace" | "correspondsTo") pfts=PredicateItem
		public Group getGroup() { return cGroup; }

		//item=(ID | STRING)
		public Assignment getItemAssignment_0() { return cItemAssignment_0; }

		//ID | STRING
		public Alternatives getItemAlternatives_0_0() { return cItemAlternatives_0_0; }

		//ID
		public RuleCall getItemIDTerminalRuleCall_0_0_0() { return cItemIDTerminalRuleCall_0_0_0; }

		//STRING
		public RuleCall getItemSTRINGTerminalRuleCall_0_0_1() { return cItemSTRINGTerminalRuleCall_0_0_1; }

		//act=("replace" | "correspondsTo")
		public Assignment getActAssignment_1() { return cActAssignment_1; }

		//"replace" | "correspondsTo"
		public Alternatives getActAlternatives_1_0() { return cActAlternatives_1_0; }

		//"replace"
		public Keyword getActReplaceKeyword_1_0_0() { return cActReplaceKeyword_1_0_0; }

		//"correspondsTo"
		public Keyword getActCorrespondsToKeyword_1_0_1() { return cActCorrespondsToKeyword_1_0_1; }

		//pfts=PredicateItem
		public Assignment getPftsAssignment_2() { return cPftsAssignment_2; }

		//PredicateItem
		public RuleCall getPftsPredicateItemParserRuleCall_2_0() { return cPftsPredicateItemParserRuleCall_2_0; }
	}

	public class PredicateItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateItem");
		private final RuleCall cOr_exprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// more complex mappings are proposed, involving some complex, advanced, predicate functions
		//// e.g., ("Free and Open Source"=YES) && ("License Cost/ Fee"=NO) => NoMoney 
		//// basically, data transformation (rewriting rules)
		//// TODO: we can extend to more complex predicates
		//PredicateItem:
		//	Or_expr;
		public ParserRule getRule() { return rule; }

		//Or_expr
		public RuleCall getOr_exprParserRuleCall() { return cOr_exprParserRuleCall; }
	}

	public class Or_exprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Or_expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAnd_exprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOr_exprLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAnd_exprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or_expr returns IExpression:
		//	And_expr ({Or_expr.left=current} "or" right=And_expr)*;
		public ParserRule getRule() { return rule; }

		//And_expr ({Or_expr.left=current} "or" right=And_expr)*
		public Group getGroup() { return cGroup; }

		//And_expr
		public RuleCall getAnd_exprParserRuleCall_0() { return cAnd_exprParserRuleCall_0; }

		//({Or_expr.left=current} "or" right=And_expr)*
		public Group getGroup_1() { return cGroup_1; }

		//{Or_expr.left=current}
		public Action getOr_exprLeftAction_1_0() { return cOr_exprLeftAction_1_0; }

		//"or"
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }

		//right=And_expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//And_expr
		public RuleCall getRightAnd_exprParserRuleCall_1_2_0() { return cRightAnd_exprParserRuleCall_1_2_0; }
	}

	public class And_exprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "And_expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnary_exprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAnd_exprLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUnary_exprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And_expr returns IExpression:
		//	Unary_expr ({And_expr.left=current} "and" right=Unary_expr)*;
		public ParserRule getRule() { return rule; }

		//Unary_expr ({And_expr.left=current} "and" right=Unary_expr)*
		public Group getGroup() { return cGroup; }

		//Unary_expr
		public RuleCall getUnary_exprParserRuleCall_0() { return cUnary_exprParserRuleCall_0; }

		//({And_expr.left=current} "and" right=Unary_expr)*
		public Group getGroup_1() { return cGroup_1; }

		//{And_expr.left=current}
		public Action getAnd_exprLeftAction_1_0() { return cAnd_exprLeftAction_1_0; }

		//"and"
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }

		//right=Unary_expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Unary_expr
		public RuleCall getRightUnary_exprParserRuleCall_1_2_0() { return cRightUnary_exprParserRuleCall_1_2_0; }
	}

	public class Unary_exprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Unary_expr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNeg_exprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPrimary_exprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Unary_expr returns IExpression:
		//	Neg_expr | Primary_expr;
		public ParserRule getRule() { return rule; }

		//Neg_expr | Primary_expr
		public Alternatives getAlternatives() { return cAlternatives; }

		//Neg_expr
		public RuleCall getNeg_exprParserRuleCall_0() { return cNeg_exprParserRuleCall_0; }

		//Primary_expr
		public RuleCall getPrimary_exprParserRuleCall_1() { return cPrimary_exprParserRuleCall_1; }
	}

	public class Neg_exprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Neg_expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNotKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprPrimary_exprParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//Neg_expr:
		//	"not" expr=Primary_expr;
		public ParserRule getRule() { return rule; }

		//"not" expr=Primary_expr
		public Group getGroup() { return cGroup; }

		//"not"
		public Keyword getNotKeyword_0() { return cNotKeyword_0; }

		//expr=Primary_expr
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Primary_expr
		public RuleCall getExprPrimary_exprParserRuleCall_1_0() { return cExprPrimary_exprParserRuleCall_1_0; }
	}

	public class Primary_exprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Primary_expr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0 = (Alternatives)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0_0 = (RuleCall)cNameAlternatives_0_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_0_1 = (RuleCall)cNameAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cOr_exprParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//Primary_expr returns IExpression:
		//	name=(ID | STRING) | "(" Or_expr ")";
		public ParserRule getRule() { return rule; }

		//name=(ID | STRING) | "(" Or_expr ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//name=(ID | STRING)
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID | STRING
		public Alternatives getNameAlternatives_0_0() { return cNameAlternatives_0_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0_0() { return cNameIDTerminalRuleCall_0_0_0; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_0_1() { return cNameSTRINGTerminalRuleCall_0_0_1; }

		//"(" Or_expr ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//Or_expr
		public RuleCall getOr_exprParserRuleCall_1_1() { return cOr_exprParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class DefaultElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Default");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDefaultAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cDefaultKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cAllviewsKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Keyword cAllKeyword_1_2 = (Keyword)cAlternatives_1.eContents().get(2);
		private final Assignment cConfigsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConfigsParsingConfigurationParserRuleCall_2_0 = (RuleCall)cConfigsAssignment_2.eContents().get(0);
		private final Assignment cProductsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cProductsScopingProductsParserRuleCall_3_0 = (RuleCall)cProductsAssignment_3.eContents().get(0);
		
		//Default:
		//	{Default} ("default:" // TODO: choose the best keyword
		//	| "allviews:" | "all:") configs=ParsingConfiguration? products=ScopingProducts?;
		public ParserRule getRule() { return rule; }

		//{Default} ("default:" // TODO: choose the best keyword
		//| "allviews:" | "all:") configs=ParsingConfiguration? products=ScopingProducts?
		public Group getGroup() { return cGroup; }

		//{Default}
		public Action getDefaultAction_0() { return cDefaultAction_0; }

		//"default:" // TODO: choose the best keyword
		//| "allviews:" | "all:"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"default:"
		public Keyword getDefaultKeyword_1_0() { return cDefaultKeyword_1_0; }

		//"allviews:"
		public Keyword getAllviewsKeyword_1_1() { return cAllviewsKeyword_1_1; }

		//"all:"
		public Keyword getAllKeyword_1_2() { return cAllKeyword_1_2; }

		//configs=ParsingConfiguration?
		public Assignment getConfigsAssignment_2() { return cConfigsAssignment_2; }

		//ParsingConfiguration
		public RuleCall getConfigsParsingConfigurationParserRuleCall_2_0() { return cConfigsParsingConfigurationParserRuleCall_2_0; }

		//products=ScopingProducts?
		public Assignment getProductsAssignment_3() { return cProductsAssignment_3; }

		//ScopingProducts
		public RuleCall getProductsScopingProductsParserRuleCall_3_0() { return cProductsScopingProductsParserRuleCall_3_0; }
	}

	public class ParsingConfigurationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParsingConfiguration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParsingConfigurationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cParsingKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cProductIDAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cProductIDKeyParserRuleCall_2_0 = (RuleCall)cProductIDAssignment_2.eContents().get(0);
		private final Assignment cFormatAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFormatFormatSpecificationParserRuleCall_3_0 = (RuleCall)cFormatAssignment_3.eContents().get(0);
		private final Assignment cSinterpretAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cSinterpretSyntacticalInterpretationParserRuleCall_4_0 = (RuleCall)cSinterpretAssignment_4.eContents().get(0);
		private final Assignment cSeparatorAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cSeparatorCSVSeparatorParserRuleCall_5_0 = (RuleCall)cSeparatorAssignment_5.eContents().get(0);
		private final Assignment cMseparatorAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cMseparatorCSVMultiSeparatorParserRuleCall_6_0 = (RuleCall)cMseparatorAssignment_6.eContents().get(0);
		
		////deprecated: fts=ScopingFeatures => features scoping should be specified in a view
		////deprecated alignment=Rewriting? =>  features rewrite should be specified in a view
		////deprecated interpretation=MultiValuesInterpretation =>  multi values interpretation should be specified in a view;
		//// could be generalized to other formats (domain-specific options) like XML, CSV, RDF, etc.
		//// parsing options can be specified for all views and/or overriden for some views 
		//ParsingConfiguration:
		//	{ParsingConfiguration} // at the moment it is limited to CSV parsing
		//	"parsing:" //deprecated: KeyID
		//	productID=Key? // otherwise, we "guess" the format with the filename extension
		//	format=FormatSpecification? sinterpret=SyntacticalInterpretation? // specific to CSV
		//	separator=CSVSeparator? // specific to CSV
		//	mseparator=CSVMultiSeparator?;
		public ParserRule getRule() { return rule; }

		//{ParsingConfiguration} // at the moment it is limited to CSV parsing
		//"parsing:" //deprecated: KeyID
		//productID=Key? // otherwise, we "guess" the format with the filename extension
		//format=FormatSpecification? sinterpret=SyntacticalInterpretation? // specific to CSV
		//separator=CSVSeparator? // specific to CSV
		//mseparator=CSVMultiSeparator?
		public Group getGroup() { return cGroup; }

		//{ParsingConfiguration}
		public Action getParsingConfigurationAction_0() { return cParsingConfigurationAction_0; }

		//// at the moment it is limited to CSV parsing
		//"parsing:"
		public Keyword getParsingKeyword_1() { return cParsingKeyword_1; }

		////deprecated: KeyID
		//productID=Key?
		public Assignment getProductIDAssignment_2() { return cProductIDAssignment_2; }

		//Key
		public RuleCall getProductIDKeyParserRuleCall_2_0() { return cProductIDKeyParserRuleCall_2_0; }

		//// otherwise, we "guess" the format with the filename extension
		//format=FormatSpecification?
		public Assignment getFormatAssignment_3() { return cFormatAssignment_3; }

		//FormatSpecification
		public RuleCall getFormatFormatSpecificationParserRuleCall_3_0() { return cFormatFormatSpecificationParserRuleCall_3_0; }

		//sinterpret=SyntacticalInterpretation?
		public Assignment getSinterpretAssignment_4() { return cSinterpretAssignment_4; }

		//SyntacticalInterpretation
		public RuleCall getSinterpretSyntacticalInterpretationParserRuleCall_4_0() { return cSinterpretSyntacticalInterpretationParserRuleCall_4_0; }

		//// specific to CSV
		//separator=CSVSeparator?
		public Assignment getSeparatorAssignment_5() { return cSeparatorAssignment_5; }

		//CSVSeparator
		public RuleCall getSeparatorCSVSeparatorParserRuleCall_5_0() { return cSeparatorCSVSeparatorParserRuleCall_5_0; }

		//// specific to CSV
		//mseparator=CSVMultiSeparator?
		public Assignment getMseparatorAssignment_6() { return cMseparatorAssignment_6; }

		//CSVMultiSeparator
		public RuleCall getMseparatorCSVMultiSeparatorParserRuleCall_6_0() { return cMseparatorCSVMultiSeparatorParserRuleCall_6_0; }
	}

	public class FormatSpecificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FormatSpecification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFormatKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFileformatAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFileformatFileFormatEnumRuleCall_1_0 = (RuleCall)cFileformatAssignment_1.eContents().get(0);
		
		//FormatSpecification:
		//	"format:" fileformat=FileFormat;
		public ParserRule getRule() { return rule; }

		//"format:" fileformat=FileFormat
		public Group getGroup() { return cGroup; }

		//"format:"
		public Keyword getFormatKeyword_0() { return cFormatKeyword_0; }

		//fileformat=FileFormat
		public Assignment getFileformatAssignment_1() { return cFileformatAssignment_1; }

		//FileFormat
		public RuleCall getFileformatFileFormatEnumRuleCall_1_0() { return cFileformatFileFormatEnumRuleCall_1_0; }
	}

	public class SyntacticalInterpretationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SyntacticalInterpretation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSyntacticalInterpretationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cVariabilityKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOptAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOptOptionalParserRuleCall_2_0 = (RuleCall)cOptAssignment_2.eContents().get(0);
		private final Assignment cYesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cYesMandatoryParserRuleCall_3_0 = (RuleCall)cYesAssignment_3.eContents().get(0);
		private final Assignment cNoAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNoNotPresentParserRuleCall_4_0 = (RuleCall)cNoAssignment_4.eContents().get(0);
		private final Assignment cNaAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cNaUnknownParserRuleCall_5_0 = (RuleCall)cNaAssignment_5.eContents().get(0);
		
		//SyntacticalInterpretation:
		//	{SyntacticalInterpretation} "variability:" opt=Optional? yes=Mandatory? no=NotPresent? na=Unknown?;
		public ParserRule getRule() { return rule; }

		//{SyntacticalInterpretation} "variability:" opt=Optional? yes=Mandatory? no=NotPresent? na=Unknown?
		public Group getGroup() { return cGroup; }

		//{SyntacticalInterpretation}
		public Action getSyntacticalInterpretationAction_0() { return cSyntacticalInterpretationAction_0; }

		//"variability:"
		public Keyword getVariabilityKeyword_1() { return cVariabilityKeyword_1; }

		//opt=Optional?
		public Assignment getOptAssignment_2() { return cOptAssignment_2; }

		//Optional
		public RuleCall getOptOptionalParserRuleCall_2_0() { return cOptOptionalParserRuleCall_2_0; }

		//yes=Mandatory?
		public Assignment getYesAssignment_3() { return cYesAssignment_3; }

		//Mandatory
		public RuleCall getYesMandatoryParserRuleCall_3_0() { return cYesMandatoryParserRuleCall_3_0; }

		//no=NotPresent?
		public Assignment getNoAssignment_4() { return cNoAssignment_4; }

		//NotPresent
		public RuleCall getNoNotPresentParserRuleCall_4_0() { return cNoNotPresentParserRuleCall_4_0; }

		//na=Unknown?
		public Assignment getNaAssignment_5() { return cNaAssignment_5; }

		//Unknown
		public RuleCall getNaUnknownParserRuleCall_5_0() { return cNaUnknownParserRuleCall_5_0; }
	}

	public class KeyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Key");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cKeyKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCidAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCidSTRINGTerminalRuleCall_1_0 = (RuleCall)cCidAssignment_1.eContents().get(0);
		
		//// note: the identifier can be composed of several identifiers
		//// A unique key comprises a single column or a set of columns. 
		//// http://en.wikipedia.org/wiki/Key_field
		//// http://en.wikipedia.org/wiki/Composite_key
		//// A key field is a field or set of fields (a key is then said to be a composite key) of a database (typically a relational database) table which together form a unique identifier for a database record (a table entry). 
		//// The aggregate of these fields is usually referred to simply as "the key". 
		//// note: do not confond with surrogate keys: http://en.wikipedia.org/wiki/Surrogate_key													
		////KeyID : Key | CompositeKey ;
		//// by default, only the first column 
		//Key:
		//	"key:" cid+=STRING+;
		public ParserRule getRule() { return rule; }

		//"key:" cid+=STRING+
		public Group getGroup() { return cGroup; }

		//"key:"
		public Keyword getKeyKeyword_0() { return cKeyKeyword_0; }

		//cid+=STRING+
		public Assignment getCidAssignment_1() { return cCidAssignment_1; }

		//STRING
		public RuleCall getCidSTRINGTerminalRuleCall_1_0() { return cCidSTRINGTerminalRuleCall_1_0; }
	}

	public class CSVSeparatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CSVSeparator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSeparatorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSepAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSepSTRINGTerminalRuleCall_1_0 = (RuleCall)cSepAssignment_1.eContents().get(0);
		
		////CompositeKey : 'compositeKey:' cid+=(STRING)+ ; 
		//// note: we authorize only one separator per CSV file which is consistent with RFC
		//CSVSeparator:
		//	"separator:" sep=STRING;
		public ParserRule getRule() { return rule; }

		//"separator:" sep=STRING
		public Group getGroup() { return cGroup; }

		//"separator:"
		public Keyword getSeparatorKeyword_0() { return cSeparatorKeyword_0; }

		//sep=STRING
		public Assignment getSepAssignment_1() { return cSepAssignment_1; }

		//STRING
		public RuleCall getSepSTRINGTerminalRuleCall_1_0() { return cSepSTRINGTerminalRuleCall_1_0; }
	}

	public class CSVMultiSeparatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CSVMultiSeparator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMultivalued_separatorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSepsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSepsSTRINGTerminalRuleCall_1_0 = (RuleCall)cSepsAssignment_1.eContents().get(0);
		
		//// here, we authorize more than one separator, even for one CSV file
		//CSVMultiSeparator:
		//	"multivalued_separator:" seps+=STRING+;
		public ParserRule getRule() { return rule; }

		//"multivalued_separator:" seps+=STRING+
		public Group getGroup() { return cGroup; }

		//"multivalued_separator:"
		public Keyword getMultivalued_separatorKeyword_0() { return cMultivalued_separatorKeyword_0; }

		//seps+=STRING+
		public Assignment getSepsAssignment_1() { return cSepsAssignment_1; }

		//STRING
		public RuleCall getSepsSTRINGTerminalRuleCall_1_0() { return cSepsSTRINGTerminalRuleCall_1_0; }
	}

	public class OptionalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Optional");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cOptionalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValuesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValuesSTRINGTerminalRuleCall_1_0 = (RuleCall)cValuesAssignment_1.eContents().get(0);
		
		//// default values to interpret as optional/partial, yes, no, N/A
		//// default: Opt / Partial
		//Optional:
		//	"optional:" values+=STRING+;
		public ParserRule getRule() { return rule; }

		//"optional:" values+=STRING+
		public Group getGroup() { return cGroup; }

		//"optional:"
		public Keyword getOptionalKeyword_0() { return cOptionalKeyword_0; }

		//values+=STRING+
		public Assignment getValuesAssignment_1() { return cValuesAssignment_1; }

		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_1_0() { return cValuesSTRINGTerminalRuleCall_1_0; }
	}

	public class MandatoryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Mandatory");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMandatoryKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValuesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValuesSTRINGTerminalRuleCall_1_0 = (RuleCall)cValuesAssignment_1.eContents().get(0);
		
		//// default: Yes, true
		//Mandatory:
		//	"mandatory:" values+=STRING+;
		public ParserRule getRule() { return rule; }

		//"mandatory:" values+=STRING+
		public Group getGroup() { return cGroup; }

		//"mandatory:"
		public Keyword getMandatoryKeyword_0() { return cMandatoryKeyword_0; }

		//values+=STRING+
		public Assignment getValuesAssignment_1() { return cValuesAssignment_1; }

		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_1_0() { return cValuesSTRINGTerminalRuleCall_1_0; }
	}

	public class NotPresentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotPresent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNotpresentKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValuesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValuesSTRINGTerminalRuleCall_1_0 = (RuleCall)cValuesAssignment_1.eContents().get(0);
		
		//// default: No, false
		//NotPresent:
		//	"notpresent:" values+=STRING+;
		public ParserRule getRule() { return rule; }

		//"notpresent:" values+=STRING+
		public Group getGroup() { return cGroup; }

		//"notpresent:"
		public Keyword getNotpresentKeyword_0() { return cNotpresentKeyword_0; }

		//values+=STRING+
		public Assignment getValuesAssignment_1() { return cValuesAssignment_1; }

		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_1_0() { return cValuesSTRINGTerminalRuleCall_1_0; }
	}

	public class UnknownElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Unknown");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUnknownKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValuesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValuesSTRINGTerminalRuleCall_1_0 = (RuleCall)cValuesAssignment_1.eContents().get(0);
		
		//// default: N/A, N_A, Unknown
		//Unknown:
		//	"unknown:" values+=STRING+;
		public ParserRule getRule() { return rule; }

		//"unknown:" values+=STRING+
		public Group getGroup() { return cGroup; }

		//"unknown:"
		public Keyword getUnknownKeyword_0() { return cUnknownKeyword_0; }

		//values+=STRING+
		public Assignment getValuesAssignment_1() { return cValuesAssignment_1; }

		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_1_0() { return cValuesSTRINGTerminalRuleCall_1_0; }
	}

	public class ScopingViewElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ScopingView");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cViewKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cViewAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cViewIDTerminalRuleCall_1_0 = (RuleCall)cViewAssignment_1.eContents().get(0);
		private final Assignment cViewnameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cViewnameViewNameParserRuleCall_2_0 = (RuleCall)cViewnameAssignment_2.eContents().get(0);
		private final Assignment cSchemaAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSchemaStructuringInformationParserRuleCall_3_0 = (RuleCall)cSchemaAssignment_3.eContents().get(0);
		private final Assignment cConfigAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConfigParsingConfigurationParserRuleCall_4_0 = (RuleCall)cConfigAssignment_4.eContents().get(0);
		private final Assignment cProductsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cProductsScopingProductsParserRuleCall_5_0 = (RuleCall)cProductsAssignment_5.eContents().get(0);
		private final Assignment cFtsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cFtsScopingFeaturesParserRuleCall_6_0 = (RuleCall)cFtsAssignment_6.eContents().get(0);
		private final Assignment cAlignmentAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cAlignmentRewritingParserRuleCall_7_0 = (RuleCall)cAlignmentAssignment_7.eContents().get(0);
		private final Assignment cInterpretationAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cInterpretationMultiValuesInterpretationParserRuleCall_8_0 = (RuleCall)cInterpretationAssignment_8.eContents().get(0);
		
		////DefaultValue : 'default_value:' values+=(STRING)+ ; // TODO: Charles
		//// by default, the name of each view gives the name of the root feature
		//// e.g., if the name of the view is "Data storage", 
		//// then the feature model that describes the view "Data storage" has "DataStorage" as root feature name
		//// TODO: specify domain-specific constraints
		//ScopingView:
		//	"view:" view= // scoping is either applied to all view or to a specific view
		//	ID viewname=ViewName? schema=StructuringInformation? config=ParsingConfiguration? products=ScopingProducts?
		//	fts=ScopingFeatures? alignment=Rewriting? interpretation=MultiValuesInterpretation?;
		public ParserRule getRule() { return rule; }

		//"view:" view= // scoping is either applied to all view or to a specific view
		//ID viewname=ViewName? schema=StructuringInformation? config=ParsingConfiguration? products=ScopingProducts?
		//fts=ScopingFeatures? alignment=Rewriting? interpretation=MultiValuesInterpretation?
		public Group getGroup() { return cGroup; }

		//"view:"
		public Keyword getViewKeyword_0() { return cViewKeyword_0; }

		//view= // scoping is either applied to all view or to a specific view
		//ID
		public Assignment getViewAssignment_1() { return cViewAssignment_1; }

		//// scoping is either applied to all view or to a specific view
		//ID
		public RuleCall getViewIDTerminalRuleCall_1_0() { return cViewIDTerminalRuleCall_1_0; }

		//viewname=ViewName?
		public Assignment getViewnameAssignment_2() { return cViewnameAssignment_2; }

		//ViewName
		public RuleCall getViewnameViewNameParserRuleCall_2_0() { return cViewnameViewNameParserRuleCall_2_0; }

		//schema=StructuringInformation?
		public Assignment getSchemaAssignment_3() { return cSchemaAssignment_3; }

		//StructuringInformation
		public RuleCall getSchemaStructuringInformationParserRuleCall_3_0() { return cSchemaStructuringInformationParserRuleCall_3_0; }

		//config=ParsingConfiguration?
		public Assignment getConfigAssignment_4() { return cConfigAssignment_4; }

		//ParsingConfiguration
		public RuleCall getConfigParsingConfigurationParserRuleCall_4_0() { return cConfigParsingConfigurationParserRuleCall_4_0; }

		//products=ScopingProducts?
		public Assignment getProductsAssignment_5() { return cProductsAssignment_5; }

		//ScopingProducts
		public RuleCall getProductsScopingProductsParserRuleCall_5_0() { return cProductsScopingProductsParserRuleCall_5_0; }

		//fts=ScopingFeatures?
		public Assignment getFtsAssignment_6() { return cFtsAssignment_6; }

		//ScopingFeatures
		public RuleCall getFtsScopingFeaturesParserRuleCall_6_0() { return cFtsScopingFeaturesParserRuleCall_6_0; }

		//alignment=Rewriting?
		public Assignment getAlignmentAssignment_7() { return cAlignmentAssignment_7; }

		//Rewriting
		public RuleCall getAlignmentRewritingParserRuleCall_7_0() { return cAlignmentRewritingParserRuleCall_7_0; }

		//interpretation=MultiValuesInterpretation?
		public Assignment getInterpretationAssignment_8() { return cInterpretationAssignment_8; }

		//MultiValuesInterpretation
		public RuleCall getInterpretationMultiValuesInterpretationParserRuleCall_8_0() { return cInterpretationMultiValuesInterpretationParserRuleCall_8_0; }
	}

	public class ViewNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ViewName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRootnameKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//ViewName:
		//	"rootname:" name=STRING;
		public ParserRule getRule() { return rule; }

		//"rootname:" name=STRING
		public Group getGroup() { return cGroup; }

		//"rootname:"
		public Keyword getRootnameKeyword_0() { return cRootnameKeyword_0; }

		//name=STRING
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0() { return cNameSTRINGTerminalRuleCall_1_0; }
	}

	public class ScopingProductsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ScopingProducts");
		private final RuleCall cProductInclusionExclusionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ScopingProducts:
		//	ProductInclusionExclusion;
		public ParserRule getRule() { return rule; }

		//ProductInclusionExclusion
		public RuleCall getProductInclusionExclusionParserRuleCall() { return cProductInclusionExclusionParserRuleCall; }
	}

	public class ScopingFeaturesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ScopingFeatures");
		private final RuleCall cFeatureInclusionExclusionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ScopingFeatures:
		//	FeatureInclusionExclusion;
		public ParserRule getRule() { return rule; }

		//FeatureInclusionExclusion
		public RuleCall getFeatureInclusionExclusionParserRuleCall() { return cFeatureInclusionExclusionParserRuleCall; }
	}

	public class FeatureInclusionExclusionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FeatureInclusionExclusion");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cExceptAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cExceptExceptFeatureParserRuleCall_0_0 = (RuleCall)cExceptAssignment_0.eContents().get(0);
		private final Assignment cOnlyAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cOnlyOnlyFeatureParserRuleCall_1_0 = (RuleCall)cOnlyAssignment_1.eContents().get(0);
		
		//FeatureInclusionExclusion:
		//	except=ExceptFeature | only=OnlyFeature;
		public ParserRule getRule() { return rule; }

		//except=ExceptFeature | only=OnlyFeature
		public Alternatives getAlternatives() { return cAlternatives; }

		//except=ExceptFeature
		public Assignment getExceptAssignment_0() { return cExceptAssignment_0; }

		//ExceptFeature
		public RuleCall getExceptExceptFeatureParserRuleCall_0_0() { return cExceptExceptFeatureParserRuleCall_0_0; }

		//only=OnlyFeature
		public Assignment getOnlyAssignment_1() { return cOnlyAssignment_1; }

		//OnlyFeature
		public RuleCall getOnlyOnlyFeatureParserRuleCall_1_0() { return cOnlyOnlyFeatureParserRuleCall_1_0; }
	}

	public class ExceptFeatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExceptFeature");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExcept_featuresKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFtsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cFtsAlternatives_1_0 = (Alternatives)cFtsAssignment_1.eContents().get(0);
		private final RuleCall cFtsIDTerminalRuleCall_1_0_0 = (RuleCall)cFtsAlternatives_1_0.eContents().get(0);
		private final RuleCall cFtsSTRINGTerminalRuleCall_1_0_1 = (RuleCall)cFtsAlternatives_1_0.eContents().get(1);
		
		//// negative: all but ...
		//ExceptFeature:
		//	"except_features:" fts+=(ID | STRING)+;
		public ParserRule getRule() { return rule; }

		//"except_features:" fts+=(ID | STRING)+
		public Group getGroup() { return cGroup; }

		//"except_features:"
		public Keyword getExcept_featuresKeyword_0() { return cExcept_featuresKeyword_0; }

		//fts+=(ID | STRING)+
		public Assignment getFtsAssignment_1() { return cFtsAssignment_1; }

		//ID | STRING
		public Alternatives getFtsAlternatives_1_0() { return cFtsAlternatives_1_0; }

		//ID
		public RuleCall getFtsIDTerminalRuleCall_1_0_0() { return cFtsIDTerminalRuleCall_1_0_0; }

		//STRING
		public RuleCall getFtsSTRINGTerminalRuleCall_1_0_1() { return cFtsSTRINGTerminalRuleCall_1_0_1; }
	}

	public class OnlyFeatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OnlyFeature");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cOnly_featuresKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFtsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cFtsAlternatives_1_0 = (Alternatives)cFtsAssignment_1.eContents().get(0);
		private final RuleCall cFtsIDTerminalRuleCall_1_0_0 = (RuleCall)cFtsAlternatives_1_0.eContents().get(0);
		private final RuleCall cFtsSTRINGTerminalRuleCall_1_0_1 = (RuleCall)cFtsAlternatives_1_0.eContents().get(1);
		
		//// positive: keeping only ...
		//OnlyFeature:
		//	"only_features:" fts+=(ID | STRING)+;
		public ParserRule getRule() { return rule; }

		//"only_features:" fts+=(ID | STRING)+
		public Group getGroup() { return cGroup; }

		//"only_features:"
		public Keyword getOnly_featuresKeyword_0() { return cOnly_featuresKeyword_0; }

		//fts+=(ID | STRING)+
		public Assignment getFtsAssignment_1() { return cFtsAssignment_1; }

		//ID | STRING
		public Alternatives getFtsAlternatives_1_0() { return cFtsAlternatives_1_0; }

		//ID
		public RuleCall getFtsIDTerminalRuleCall_1_0_0() { return cFtsIDTerminalRuleCall_1_0_0; }

		//STRING
		public RuleCall getFtsSTRINGTerminalRuleCall_1_0_1() { return cFtsSTRINGTerminalRuleCall_1_0_1; }
	}

	public class ProductInclusionExclusionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProductInclusionExclusion");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cExceptAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cExceptExceptProductParserRuleCall_0_0 = (RuleCall)cExceptAssignment_0.eContents().get(0);
		private final Assignment cOnlyAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cOnlyOnlyProductParserRuleCall_1_0 = (RuleCall)cOnlyAssignment_1.eContents().get(0);
		
		//// due to composite key, manage qualified identifier
		//// e.g., only_products: ATI.Nvidia
		//ProductInclusionExclusion:
		//	except=ExceptProduct | only=OnlyProduct;
		public ParserRule getRule() { return rule; }

		//except=ExceptProduct | only=OnlyProduct
		public Alternatives getAlternatives() { return cAlternatives; }

		//except=ExceptProduct
		public Assignment getExceptAssignment_0() { return cExceptAssignment_0; }

		//ExceptProduct
		public RuleCall getExceptExceptProductParserRuleCall_0_0() { return cExceptExceptProductParserRuleCall_0_0; }

		//only=OnlyProduct
		public Assignment getOnlyAssignment_1() { return cOnlyAssignment_1; }

		//OnlyProduct
		public RuleCall getOnlyOnlyProductParserRuleCall_1_0() { return cOnlyOnlyProductParserRuleCall_1_0; }
	}

	public class ExceptProductElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExceptProduct");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExcept_productsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPdsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cPdsAlternatives_1_0 = (Alternatives)cPdsAssignment_1.eContents().get(0);
		private final RuleCall cPdsIDTerminalRuleCall_1_0_0 = (RuleCall)cPdsAlternatives_1_0.eContents().get(0);
		private final RuleCall cPdsSTRINGTerminalRuleCall_1_0_1 = (RuleCall)cPdsAlternatives_1_0.eContents().get(1);
		
		//// negative: all but ...
		//ExceptProduct:
		//	"except_products:" pds+=(ID | STRING)+;
		public ParserRule getRule() { return rule; }

		//"except_products:" pds+=(ID | STRING)+
		public Group getGroup() { return cGroup; }

		//"except_products:"
		public Keyword getExcept_productsKeyword_0() { return cExcept_productsKeyword_0; }

		//pds+=(ID | STRING)+
		public Assignment getPdsAssignment_1() { return cPdsAssignment_1; }

		//ID | STRING
		public Alternatives getPdsAlternatives_1_0() { return cPdsAlternatives_1_0; }

		//ID
		public RuleCall getPdsIDTerminalRuleCall_1_0_0() { return cPdsIDTerminalRuleCall_1_0_0; }

		//STRING
		public RuleCall getPdsSTRINGTerminalRuleCall_1_0_1() { return cPdsSTRINGTerminalRuleCall_1_0_1; }
	}

	public class OnlyProductElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OnlyProduct");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cOnly_productsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPdsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cPdsAlternatives_1_0 = (Alternatives)cPdsAssignment_1.eContents().get(0);
		private final RuleCall cPdsIDTerminalRuleCall_1_0_0 = (RuleCall)cPdsAlternatives_1_0.eContents().get(0);
		private final RuleCall cPdsSTRINGTerminalRuleCall_1_0_1 = (RuleCall)cPdsAlternatives_1_0.eContents().get(1);
		
		//// positive: keeping only ...
		//OnlyProduct:
		//	"only_products:" pds+=(ID | STRING)+;
		public ParserRule getRule() { return rule; }

		//"only_products:" pds+=(ID | STRING)+
		public Group getGroup() { return cGroup; }

		//"only_products:"
		public Keyword getOnly_productsKeyword_0() { return cOnly_productsKeyword_0; }

		//pds+=(ID | STRING)+
		public Assignment getPdsAssignment_1() { return cPdsAssignment_1; }

		//ID | STRING
		public Alternatives getPdsAlternatives_1_0() { return cPdsAlternatives_1_0; }

		//ID
		public RuleCall getPdsIDTerminalRuleCall_1_0_0() { return cPdsIDTerminalRuleCall_1_0_0; }

		//STRING
		public RuleCall getPdsSTRINGTerminalRuleCall_1_0_1() { return cPdsSTRINGTerminalRuleCall_1_0_1; }
	}

	public class RewritingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Rewriting");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cRewritingKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cRenamingKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Assignment cOftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cOftAlternatives_1_0 = (Alternatives)cOftAssignment_1.eContents().get(0);
		private final RuleCall cOftIDTerminalRuleCall_1_0_0 = (RuleCall)cOftAlternatives_1_0.eContents().get(0);
		private final RuleCall cOftSTRINGTerminalRuleCall_1_0_1 = (RuleCall)cOftAlternatives_1_0.eContents().get(1);
		private final Keyword cEqualsSignGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNftAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNftSTRINGTerminalRuleCall_3_0 = (RuleCall)cNftAssignment_3.eContents().get(0);
		
		//// see also StructuringInformation
		//Rewriting:
		//	("rewriting:" | "renaming:") oft=(ID | STRING) "=>" nft=STRING;
		public ParserRule getRule() { return rule; }

		//("rewriting:" | "renaming:") oft=(ID | STRING) "=>" nft=STRING
		public Group getGroup() { return cGroup; }

		//"rewriting:" | "renaming:"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"rewriting:"
		public Keyword getRewritingKeyword_0_0() { return cRewritingKeyword_0_0; }

		//"renaming:"
		public Keyword getRenamingKeyword_0_1() { return cRenamingKeyword_0_1; }

		//oft=(ID | STRING)
		public Assignment getOftAssignment_1() { return cOftAssignment_1; }

		//ID | STRING
		public Alternatives getOftAlternatives_1_0() { return cOftAlternatives_1_0; }

		//ID
		public RuleCall getOftIDTerminalRuleCall_1_0_0() { return cOftIDTerminalRuleCall_1_0_0; }

		//STRING
		public RuleCall getOftSTRINGTerminalRuleCall_1_0_1() { return cOftSTRINGTerminalRuleCall_1_0_1; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_2() { return cEqualsSignGreaterThanSignKeyword_2; }

		//nft=STRING
		public Assignment getNftAssignment_3() { return cNftAssignment_3; }

		//STRING
		public RuleCall getNftSTRINGTerminalRuleCall_3_0() { return cNftSTRINGTerminalRuleCall_3_0; }
	}

	public class MultiValuesInterpretationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiValuesInterpretation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMultivaluesKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cMultiAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMultiMultiValueInterpretationParserRuleCall_1_0 = (RuleCall)cMultiAssignment_1.eContents().get(0);
		
		//MultiValuesInterpretation:
		//	"multivalues:" multi+=MultiValueInterpretation+;
		public ParserRule getRule() { return rule; }

		//"multivalues:" multi+=MultiValueInterpretation+
		public Group getGroup() { return cGroup; }

		//"multivalues:"
		public Keyword getMultivaluesKeyword_0() { return cMultivaluesKeyword_0; }

		//multi+=MultiValueInterpretation+
		public Assignment getMultiAssignment_1() { return cMultiAssignment_1; }

		//MultiValueInterpretation
		public RuleCall getMultiMultiValueInterpretationParserRuleCall_1_0() { return cMultiMultiValueInterpretationParserRuleCall_1_0; }
	}

	public class MultiValueInterpretationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiValueInterpretation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cValAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cValAlternatives_0_0 = (Alternatives)cValAssignment_0.eContents().get(0);
		private final RuleCall cValIDTerminalRuleCall_0_0_0 = (RuleCall)cValAlternatives_0_0.eContents().get(0);
		private final RuleCall cValSTRINGTerminalRuleCall_0_0_1 = (RuleCall)cValAlternatives_0_0.eContents().get(1);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVariabilityAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVariabilityVariabilityInterpretationEnumRuleCall_2_0 = (RuleCall)cVariabilityAssignment_2.eContents().get(0);
		
		//// val is the name of a column
		//MultiValueInterpretation:
		//	val=(ID | STRING) "=>" variability=VariabilityInterpretation;
		public ParserRule getRule() { return rule; }

		//val=(ID | STRING) "=>" variability=VariabilityInterpretation
		public Group getGroup() { return cGroup; }

		//val=(ID | STRING)
		public Assignment getValAssignment_0() { return cValAssignment_0; }

		//ID | STRING
		public Alternatives getValAlternatives_0_0() { return cValAlternatives_0_0; }

		//ID
		public RuleCall getValIDTerminalRuleCall_0_0_0() { return cValIDTerminalRuleCall_0_0_0; }

		//STRING
		public RuleCall getValSTRINGTerminalRuleCall_0_0_1() { return cValSTRINGTerminalRuleCall_0_0_1; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_1() { return cEqualsSignGreaterThanSignKeyword_1; }

		//variability=VariabilityInterpretation
		public Assignment getVariabilityAssignment_2() { return cVariabilityAssignment_2; }

		//VariabilityInterpretation
		public RuleCall getVariabilityVariabilityInterpretationEnumRuleCall_2_0() { return cVariabilityVariabilityInterpretationEnumRuleCall_2_0; }
	}
	
	
	public class KindRelationElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "KindRelation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBELOWEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBELOWBelowKeyword_0_0 = (Keyword)cBELOWEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cABOVEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cABOVEAboveKeyword_1_0 = (Keyword)cABOVEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMOVEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMOVEMoveInKeyword_2_0 = (Keyword)cMOVEEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cCOPYEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cCOPYCopyInKeyword_3_0 = (Keyword)cCOPYEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum KindRelation:
		//	BELOW="below" | ABOVE="above" | MOVE="moveIn" | COPY="copyIn";
		public EnumRule getRule() { return rule; }

		//BELOW="below" | ABOVE="above" | MOVE="moveIn" | COPY="copyIn"
		public Alternatives getAlternatives() { return cAlternatives; }

		//BELOW="below"
		public EnumLiteralDeclaration getBELOWEnumLiteralDeclaration_0() { return cBELOWEnumLiteralDeclaration_0; }

		//"below"
		public Keyword getBELOWBelowKeyword_0_0() { return cBELOWBelowKeyword_0_0; }

		//ABOVE="above"
		public EnumLiteralDeclaration getABOVEEnumLiteralDeclaration_1() { return cABOVEEnumLiteralDeclaration_1; }

		//"above"
		public Keyword getABOVEAboveKeyword_1_0() { return cABOVEAboveKeyword_1_0; }

		//MOVE="moveIn"
		public EnumLiteralDeclaration getMOVEEnumLiteralDeclaration_2() { return cMOVEEnumLiteralDeclaration_2; }

		//"moveIn"
		public Keyword getMOVEMoveInKeyword_2_0() { return cMOVEMoveInKeyword_2_0; }

		//COPY="copyIn"
		public EnumLiteralDeclaration getCOPYEnumLiteralDeclaration_3() { return cCOPYEnumLiteralDeclaration_3; }

		//"copyIn"
		public Keyword getCOPYCopyInKeyword_3_0() { return cCOPYCopyInKeyword_3_0; }
	}

	public class FileFormatElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "FileFormat");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCSVEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCSVCSVKeyword_0_0 = (Keyword)cCSVEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cRDFEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cRDFRDFKeyword_1_0 = (Keyword)cRDFEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cXMLEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cXMLXMLKeyword_2_0 = (Keyword)cXMLEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum FileFormat:
		//	CSV | RDF | XML;
		public EnumRule getRule() { return rule; }

		//CSV | RDF | XML
		public Alternatives getAlternatives() { return cAlternatives; }

		//CSV
		public EnumLiteralDeclaration getCSVEnumLiteralDeclaration_0() { return cCSVEnumLiteralDeclaration_0; }

		//"CSV"
		public Keyword getCSVCSVKeyword_0_0() { return cCSVCSVKeyword_0_0; }

		//RDF
		public EnumLiteralDeclaration getRDFEnumLiteralDeclaration_1() { return cRDFEnumLiteralDeclaration_1; }

		//"RDF"
		public Keyword getRDFRDFKeyword_1_0() { return cRDFRDFKeyword_1_0; }

		//XML
		public EnumLiteralDeclaration getXMLEnumLiteralDeclaration_2() { return cXMLEnumLiteralDeclaration_2; }

		//"XML"
		public Keyword getXMLXMLKeyword_2_0() { return cXMLXMLKeyword_2_0; }
	}

	public class VariabilityInterpretationElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "VariabilityInterpretation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cXOREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cXORAlternativesKeyword_0_0 = (Keyword)cXOREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cORORAlternativesKeyword_1_0 = (Keyword)cOREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cOPTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cOPTOptionalKeyword_2_0 = (Keyword)cOPTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cMANDEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cMANDMandatoryKeyword_3_0 = (Keyword)cMANDEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cCONCATEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cCONCATConcatKeyword_4_0 = (Keyword)cCONCATEnumLiteralDeclaration_4.eContents().get(0);
		
		//// TODO: generalize to i..j (XOR ~> 1..1)
		//enum VariabilityInterpretation:
		//	XOR="Alternatives" | OR="OR-Alternatives" | OPT="Optional" | MAND="Mandatory" | CONCAT="Concat";
		public EnumRule getRule() { return rule; }

		//XOR="Alternatives" | OR="OR-Alternatives" | OPT="Optional" | MAND="Mandatory" | CONCAT="Concat"
		public Alternatives getAlternatives() { return cAlternatives; }

		//XOR="Alternatives"
		public EnumLiteralDeclaration getXOREnumLiteralDeclaration_0() { return cXOREnumLiteralDeclaration_0; }

		//"Alternatives"
		public Keyword getXORAlternativesKeyword_0_0() { return cXORAlternativesKeyword_0_0; }

		//OR="OR-Alternatives"
		public EnumLiteralDeclaration getOREnumLiteralDeclaration_1() { return cOREnumLiteralDeclaration_1; }

		//"OR-Alternatives"
		public Keyword getORORAlternativesKeyword_1_0() { return cORORAlternativesKeyword_1_0; }

		//OPT="Optional"
		public EnumLiteralDeclaration getOPTEnumLiteralDeclaration_2() { return cOPTEnumLiteralDeclaration_2; }

		//"Optional"
		public Keyword getOPTOptionalKeyword_2_0() { return cOPTOptionalKeyword_2_0; }

		//MAND="Mandatory"
		public EnumLiteralDeclaration getMANDEnumLiteralDeclaration_3() { return cMANDEnumLiteralDeclaration_3; }

		//"Mandatory"
		public Keyword getMANDMandatoryKeyword_3_0() { return cMANDMandatoryKeyword_3_0; }

		//CONCAT="Concat"
		public EnumLiteralDeclaration getCONCATEnumLiteralDeclaration_4() { return cCONCATEnumLiteralDeclaration_4; }

		//"Concat"
		public Keyword getCONCATConcatKeyword_4_0() { return cCONCATConcatKeyword_4_0; }
	}
	
	private SToFMModelElements pSToFMModel;
	private ImportViewsElements pImportViews;
	private DataViewElements pDataView;
	private SPLNameElements pSPLName;
	private StructuringInformationElements pStructuringInformation;
	private ItemRelationElements pItemRelation;
	private KindRelationElements unknownRuleKindRelation;
	private ItemGeneralizationElements pItemGeneralization;
	private ItemMappingElements pItemMapping;
	private PredicateItemElements pPredicateItem;
	private Or_exprElements pOr_expr;
	private And_exprElements pAnd_expr;
	private Unary_exprElements pUnary_expr;
	private Neg_exprElements pNeg_expr;
	private Primary_exprElements pPrimary_expr;
	private DefaultElements pDefault;
	private ParsingConfigurationElements pParsingConfiguration;
	private FormatSpecificationElements pFormatSpecification;
	private FileFormatElements unknownRuleFileFormat;
	private SyntacticalInterpretationElements pSyntacticalInterpretation;
	private KeyElements pKey;
	private CSVSeparatorElements pCSVSeparator;
	private CSVMultiSeparatorElements pCSVMultiSeparator;
	private OptionalElements pOptional;
	private MandatoryElements pMandatory;
	private NotPresentElements pNotPresent;
	private UnknownElements pUnknown;
	private ScopingViewElements pScopingView;
	private ViewNameElements pViewName;
	private ScopingProductsElements pScopingProducts;
	private ScopingFeaturesElements pScopingFeatures;
	private FeatureInclusionExclusionElements pFeatureInclusionExclusion;
	private ExceptFeatureElements pExceptFeature;
	private OnlyFeatureElements pOnlyFeature;
	private ProductInclusionExclusionElements pProductInclusionExclusion;
	private ExceptProductElements pExceptProduct;
	private OnlyProductElements pOnlyProduct;
	private RewritingElements pRewriting;
	private MultiValuesInterpretationElements pMultiValuesInterpretation;
	private MultiValueInterpretationElements pMultiValueInterpretation;
	private VariabilityInterpretationElements unknownRuleVariabilityInterpretation;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public VariCellGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.mydsl.VariCell".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////"A domain-specific language can parameterize command line input".
	////OK, let us start with an DSL 
	////for extracting feature models from sources (e.g., semi-structured products specification)
	//SToFMModel:
	//	importViews= // a set of views
	//	ImportViews splName= // aka name of the integrated view aka root feature name in the resulting feature model
	//	SPLName // e.g., relationship between views
	//	schema=StructuringInformation? // default interpretation of data for *all* views
	//	default=Default? // the interpretation can be overriden in each view
	//	scoping+=ScopingView*;
	public SToFMModelElements getSToFMModelAccess() {
		return (pSToFMModel != null) ? pSToFMModel : (pSToFMModel = new SToFMModelElements());
	}
	
	public ParserRule getSToFMModelRule() {
		return getSToFMModelAccess().getRule();
	}

	//ImportViews:
	//	"import:" views+=DataView+;
	public ImportViewsElements getImportViewsAccess() {
		return (pImportViews != null) ? pImportViews : (pImportViews = new ImportViewsElements());
	}
	
	public ParserRule getImportViewsRule() {
		return getImportViewsAccess().getRule();
	}

	//// TODO: by default, the name of each view is the name of the file
	//DataView:
	//	file=STRING ("as" viewname=ID)?;
	public DataViewElements getDataViewAccess() {
		return (pDataView != null) ? pDataView : (pDataView = new DataViewElements());
	}
	
	public ParserRule getDataViewRule() {
		return getDataViewAccess().getRule();
	}

	//// basically, root name
	//SPLName:
	//	"name:" name=(STRING | ID);
	public SPLNameElements getSPLNameAccess() {
		return (pSPLName != null) ? pSPLName : (pSPLName = new SPLNameElements());
	}
	
	public ParserRule getSPLNameRule() {
		return getSPLNameAccess().getRule();
	}

	/// *
	//Wikipedia:
	//A hierarchy is an arrangement of items (objects, names, values, categories, etc.) 
	//in which the items are represented as being "above," "below," or "at the same level as" one another. 
	//Here: items are views/(features within a view) 
	//// by default, all views (resp. features within a view) are at the same level, below the high-level concept (e.g., SPL name or view name)
	//TODO: I would say that even features in a specific view can be hierarchycally organize
	// * / StructuringInformation:
	//	{StructuringInformation} "structure:" relations+=ItemRelation* abstract+=ItemGeneralization* mp+=ItemMapping*;
	public StructuringInformationElements getStructuringInformationAccess() {
		return (pStructuringInformation != null) ? pStructuringInformation : (pStructuringInformation = new StructuringInformationElements());
	}
	
	public ParserRule getStructuringInformationRule() {
		return getStructuringInformationAccess().getRule();
	}

	//// basically, a parent-child hierarchy
	//ItemRelation:
	//	view1=(ID | STRING) rel=KindRelation view2=(ID | STRING);
	public ItemRelationElements getItemRelationAccess() {
		return (pItemRelation != null) ? pItemRelation : (pItemRelation = new ItemRelationElements());
	}
	
	public ParserRule getItemRelationRule() {
		return getItemRelationAccess().getRule();
	}

	//enum KindRelation:
	//	BELOW="below" | ABOVE="above" | MOVE="moveIn" | COPY="copyIn";
	public KindRelationElements getKindRelationAccess() {
		return (unknownRuleKindRelation != null) ? unknownRuleKindRelation : (unknownRuleKindRelation = new KindRelationElements());
	}
	
	public EnumRule getKindRelationRule() {
		return getKindRelationAccess().getRule();
	}

	////http://www.utexas.edu/its/archive/windows/database/datamodeling/dm/erintro.html: 
	////A generalization hierarchy is a form of abstraction that specifies that two or more entities that share common attributes can be generalized into a higher level entity type called a supertype or generic entity. 
	////The lower-level of entities become the subtype, or categories, to the supertype. Subtypes are dependent entities.
	//ItemGeneralization:
	//	generalize=(ID | STRING) ("generalize" | "abstract") views+=(ID | STRING)+;
	public ItemGeneralizationElements getItemGeneralizationAccess() {
		return (pItemGeneralization != null) ? pItemGeneralization : (pItemGeneralization = new ItemGeneralizationElements());
	}
	
	public ParserRule getItemGeneralizationRule() {
		return getItemGeneralizationAccess().getRule();
	}

	//// item corresponds to ....
	//// e.g., SQL correspondsTo (MySQL or PostgreSQL or SQLite)
	//// I made a difference between replace and correspondsTo
	//// replace: pfts no longer appear in the resulting feature model whereas nfeature is added
	//// correspondsTo: nfeature is added in the resulting feature model as well as pfts 
	//// (nfeature is basically an optional feature (TODO: where in the hierarchy?) related to pfts features by propositional constraints)
	//ItemMapping:
	//	item=(ID | STRING) act=("replace" | "correspondsTo") pfts=PredicateItem;
	public ItemMappingElements getItemMappingAccess() {
		return (pItemMapping != null) ? pItemMapping : (pItemMapping = new ItemMappingElements());
	}
	
	public ParserRule getItemMappingRule() {
		return getItemMappingAccess().getRule();
	}

	//// more complex mappings are proposed, involving some complex, advanced, predicate functions
	//// e.g., ("Free and Open Source"=YES) && ("License Cost/ Fee"=NO) => NoMoney 
	//// basically, data transformation (rewriting rules)
	//// TODO: we can extend to more complex predicates
	//PredicateItem:
	//	Or_expr;
	public PredicateItemElements getPredicateItemAccess() {
		return (pPredicateItem != null) ? pPredicateItem : (pPredicateItem = new PredicateItemElements());
	}
	
	public ParserRule getPredicateItemRule() {
		return getPredicateItemAccess().getRule();
	}

	//Or_expr returns IExpression:
	//	And_expr ({Or_expr.left=current} "or" right=And_expr)*;
	public Or_exprElements getOr_exprAccess() {
		return (pOr_expr != null) ? pOr_expr : (pOr_expr = new Or_exprElements());
	}
	
	public ParserRule getOr_exprRule() {
		return getOr_exprAccess().getRule();
	}

	//And_expr returns IExpression:
	//	Unary_expr ({And_expr.left=current} "and" right=Unary_expr)*;
	public And_exprElements getAnd_exprAccess() {
		return (pAnd_expr != null) ? pAnd_expr : (pAnd_expr = new And_exprElements());
	}
	
	public ParserRule getAnd_exprRule() {
		return getAnd_exprAccess().getRule();
	}

	//Unary_expr returns IExpression:
	//	Neg_expr | Primary_expr;
	public Unary_exprElements getUnary_exprAccess() {
		return (pUnary_expr != null) ? pUnary_expr : (pUnary_expr = new Unary_exprElements());
	}
	
	public ParserRule getUnary_exprRule() {
		return getUnary_exprAccess().getRule();
	}

	//Neg_expr:
	//	"not" expr=Primary_expr;
	public Neg_exprElements getNeg_exprAccess() {
		return (pNeg_expr != null) ? pNeg_expr : (pNeg_expr = new Neg_exprElements());
	}
	
	public ParserRule getNeg_exprRule() {
		return getNeg_exprAccess().getRule();
	}

	//Primary_expr returns IExpression:
	//	name=(ID | STRING) | "(" Or_expr ")";
	public Primary_exprElements getPrimary_exprAccess() {
		return (pPrimary_expr != null) ? pPrimary_expr : (pPrimary_expr = new Primary_exprElements());
	}
	
	public ParserRule getPrimary_exprRule() {
		return getPrimary_exprAccess().getRule();
	}

	//Default:
	//	{Default} ("default:" // TODO: choose the best keyword
	//	| "allviews:" | "all:") configs=ParsingConfiguration? products=ScopingProducts?;
	public DefaultElements getDefaultAccess() {
		return (pDefault != null) ? pDefault : (pDefault = new DefaultElements());
	}
	
	public ParserRule getDefaultRule() {
		return getDefaultAccess().getRule();
	}

	////deprecated: fts=ScopingFeatures => features scoping should be specified in a view
	////deprecated alignment=Rewriting? =>  features rewrite should be specified in a view
	////deprecated interpretation=MultiValuesInterpretation =>  multi values interpretation should be specified in a view;
	//// could be generalized to other formats (domain-specific options) like XML, CSV, RDF, etc.
	//// parsing options can be specified for all views and/or overriden for some views 
	//ParsingConfiguration:
	//	{ParsingConfiguration} // at the moment it is limited to CSV parsing
	//	"parsing:" //deprecated: KeyID
	//	productID=Key? // otherwise, we "guess" the format with the filename extension
	//	format=FormatSpecification? sinterpret=SyntacticalInterpretation? // specific to CSV
	//	separator=CSVSeparator? // specific to CSV
	//	mseparator=CSVMultiSeparator?;
	public ParsingConfigurationElements getParsingConfigurationAccess() {
		return (pParsingConfiguration != null) ? pParsingConfiguration : (pParsingConfiguration = new ParsingConfigurationElements());
	}
	
	public ParserRule getParsingConfigurationRule() {
		return getParsingConfigurationAccess().getRule();
	}

	//FormatSpecification:
	//	"format:" fileformat=FileFormat;
	public FormatSpecificationElements getFormatSpecificationAccess() {
		return (pFormatSpecification != null) ? pFormatSpecification : (pFormatSpecification = new FormatSpecificationElements());
	}
	
	public ParserRule getFormatSpecificationRule() {
		return getFormatSpecificationAccess().getRule();
	}

	//enum FileFormat:
	//	CSV | RDF | XML;
	public FileFormatElements getFileFormatAccess() {
		return (unknownRuleFileFormat != null) ? unknownRuleFileFormat : (unknownRuleFileFormat = new FileFormatElements());
	}
	
	public EnumRule getFileFormatRule() {
		return getFileFormatAccess().getRule();
	}

	//SyntacticalInterpretation:
	//	{SyntacticalInterpretation} "variability:" opt=Optional? yes=Mandatory? no=NotPresent? na=Unknown?;
	public SyntacticalInterpretationElements getSyntacticalInterpretationAccess() {
		return (pSyntacticalInterpretation != null) ? pSyntacticalInterpretation : (pSyntacticalInterpretation = new SyntacticalInterpretationElements());
	}
	
	public ParserRule getSyntacticalInterpretationRule() {
		return getSyntacticalInterpretationAccess().getRule();
	}

	//// note: the identifier can be composed of several identifiers
	//// A unique key comprises a single column or a set of columns. 
	//// http://en.wikipedia.org/wiki/Key_field
	//// http://en.wikipedia.org/wiki/Composite_key
	//// A key field is a field or set of fields (a key is then said to be a composite key) of a database (typically a relational database) table which together form a unique identifier for a database record (a table entry). 
	//// The aggregate of these fields is usually referred to simply as "the key". 
	//// note: do not confond with surrogate keys: http://en.wikipedia.org/wiki/Surrogate_key													
	////KeyID : Key | CompositeKey ;
	//// by default, only the first column 
	//Key:
	//	"key:" cid+=STRING+;
	public KeyElements getKeyAccess() {
		return (pKey != null) ? pKey : (pKey = new KeyElements());
	}
	
	public ParserRule getKeyRule() {
		return getKeyAccess().getRule();
	}

	////CompositeKey : 'compositeKey:' cid+=(STRING)+ ; 
	//// note: we authorize only one separator per CSV file which is consistent with RFC
	//CSVSeparator:
	//	"separator:" sep=STRING;
	public CSVSeparatorElements getCSVSeparatorAccess() {
		return (pCSVSeparator != null) ? pCSVSeparator : (pCSVSeparator = new CSVSeparatorElements());
	}
	
	public ParserRule getCSVSeparatorRule() {
		return getCSVSeparatorAccess().getRule();
	}

	//// here, we authorize more than one separator, even for one CSV file
	//CSVMultiSeparator:
	//	"multivalued_separator:" seps+=STRING+;
	public CSVMultiSeparatorElements getCSVMultiSeparatorAccess() {
		return (pCSVMultiSeparator != null) ? pCSVMultiSeparator : (pCSVMultiSeparator = new CSVMultiSeparatorElements());
	}
	
	public ParserRule getCSVMultiSeparatorRule() {
		return getCSVMultiSeparatorAccess().getRule();
	}

	//// default values to interpret as optional/partial, yes, no, N/A
	//// default: Opt / Partial
	//Optional:
	//	"optional:" values+=STRING+;
	public OptionalElements getOptionalAccess() {
		return (pOptional != null) ? pOptional : (pOptional = new OptionalElements());
	}
	
	public ParserRule getOptionalRule() {
		return getOptionalAccess().getRule();
	}

	//// default: Yes, true
	//Mandatory:
	//	"mandatory:" values+=STRING+;
	public MandatoryElements getMandatoryAccess() {
		return (pMandatory != null) ? pMandatory : (pMandatory = new MandatoryElements());
	}
	
	public ParserRule getMandatoryRule() {
		return getMandatoryAccess().getRule();
	}

	//// default: No, false
	//NotPresent:
	//	"notpresent:" values+=STRING+;
	public NotPresentElements getNotPresentAccess() {
		return (pNotPresent != null) ? pNotPresent : (pNotPresent = new NotPresentElements());
	}
	
	public ParserRule getNotPresentRule() {
		return getNotPresentAccess().getRule();
	}

	//// default: N/A, N_A, Unknown
	//Unknown:
	//	"unknown:" values+=STRING+;
	public UnknownElements getUnknownAccess() {
		return (pUnknown != null) ? pUnknown : (pUnknown = new UnknownElements());
	}
	
	public ParserRule getUnknownRule() {
		return getUnknownAccess().getRule();
	}

	////DefaultValue : 'default_value:' values+=(STRING)+ ; // TODO: Charles
	//// by default, the name of each view gives the name of the root feature
	//// e.g., if the name of the view is "Data storage", 
	//// then the feature model that describes the view "Data storage" has "DataStorage" as root feature name
	//// TODO: specify domain-specific constraints
	//ScopingView:
	//	"view:" view= // scoping is either applied to all view or to a specific view
	//	ID viewname=ViewName? schema=StructuringInformation? config=ParsingConfiguration? products=ScopingProducts?
	//	fts=ScopingFeatures? alignment=Rewriting? interpretation=MultiValuesInterpretation?;
	public ScopingViewElements getScopingViewAccess() {
		return (pScopingView != null) ? pScopingView : (pScopingView = new ScopingViewElements());
	}
	
	public ParserRule getScopingViewRule() {
		return getScopingViewAccess().getRule();
	}

	//ViewName:
	//	"rootname:" name=STRING;
	public ViewNameElements getViewNameAccess() {
		return (pViewName != null) ? pViewName : (pViewName = new ViewNameElements());
	}
	
	public ParserRule getViewNameRule() {
		return getViewNameAccess().getRule();
	}

	//ScopingProducts:
	//	ProductInclusionExclusion;
	public ScopingProductsElements getScopingProductsAccess() {
		return (pScopingProducts != null) ? pScopingProducts : (pScopingProducts = new ScopingProductsElements());
	}
	
	public ParserRule getScopingProductsRule() {
		return getScopingProductsAccess().getRule();
	}

	//ScopingFeatures:
	//	FeatureInclusionExclusion;
	public ScopingFeaturesElements getScopingFeaturesAccess() {
		return (pScopingFeatures != null) ? pScopingFeatures : (pScopingFeatures = new ScopingFeaturesElements());
	}
	
	public ParserRule getScopingFeaturesRule() {
		return getScopingFeaturesAccess().getRule();
	}

	//FeatureInclusionExclusion:
	//	except=ExceptFeature | only=OnlyFeature;
	public FeatureInclusionExclusionElements getFeatureInclusionExclusionAccess() {
		return (pFeatureInclusionExclusion != null) ? pFeatureInclusionExclusion : (pFeatureInclusionExclusion = new FeatureInclusionExclusionElements());
	}
	
	public ParserRule getFeatureInclusionExclusionRule() {
		return getFeatureInclusionExclusionAccess().getRule();
	}

	//// negative: all but ...
	//ExceptFeature:
	//	"except_features:" fts+=(ID | STRING)+;
	public ExceptFeatureElements getExceptFeatureAccess() {
		return (pExceptFeature != null) ? pExceptFeature : (pExceptFeature = new ExceptFeatureElements());
	}
	
	public ParserRule getExceptFeatureRule() {
		return getExceptFeatureAccess().getRule();
	}

	//// positive: keeping only ...
	//OnlyFeature:
	//	"only_features:" fts+=(ID | STRING)+;
	public OnlyFeatureElements getOnlyFeatureAccess() {
		return (pOnlyFeature != null) ? pOnlyFeature : (pOnlyFeature = new OnlyFeatureElements());
	}
	
	public ParserRule getOnlyFeatureRule() {
		return getOnlyFeatureAccess().getRule();
	}

	//// due to composite key, manage qualified identifier
	//// e.g., only_products: ATI.Nvidia
	//ProductInclusionExclusion:
	//	except=ExceptProduct | only=OnlyProduct;
	public ProductInclusionExclusionElements getProductInclusionExclusionAccess() {
		return (pProductInclusionExclusion != null) ? pProductInclusionExclusion : (pProductInclusionExclusion = new ProductInclusionExclusionElements());
	}
	
	public ParserRule getProductInclusionExclusionRule() {
		return getProductInclusionExclusionAccess().getRule();
	}

	//// negative: all but ...
	//ExceptProduct:
	//	"except_products:" pds+=(ID | STRING)+;
	public ExceptProductElements getExceptProductAccess() {
		return (pExceptProduct != null) ? pExceptProduct : (pExceptProduct = new ExceptProductElements());
	}
	
	public ParserRule getExceptProductRule() {
		return getExceptProductAccess().getRule();
	}

	//// positive: keeping only ...
	//OnlyProduct:
	//	"only_products:" pds+=(ID | STRING)+;
	public OnlyProductElements getOnlyProductAccess() {
		return (pOnlyProduct != null) ? pOnlyProduct : (pOnlyProduct = new OnlyProductElements());
	}
	
	public ParserRule getOnlyProductRule() {
		return getOnlyProductAccess().getRule();
	}

	//// see also StructuringInformation
	//Rewriting:
	//	("rewriting:" | "renaming:") oft=(ID | STRING) "=>" nft=STRING;
	public RewritingElements getRewritingAccess() {
		return (pRewriting != null) ? pRewriting : (pRewriting = new RewritingElements());
	}
	
	public ParserRule getRewritingRule() {
		return getRewritingAccess().getRule();
	}

	//MultiValuesInterpretation:
	//	"multivalues:" multi+=MultiValueInterpretation+;
	public MultiValuesInterpretationElements getMultiValuesInterpretationAccess() {
		return (pMultiValuesInterpretation != null) ? pMultiValuesInterpretation : (pMultiValuesInterpretation = new MultiValuesInterpretationElements());
	}
	
	public ParserRule getMultiValuesInterpretationRule() {
		return getMultiValuesInterpretationAccess().getRule();
	}

	//// val is the name of a column
	//MultiValueInterpretation:
	//	val=(ID | STRING) "=>" variability=VariabilityInterpretation;
	public MultiValueInterpretationElements getMultiValueInterpretationAccess() {
		return (pMultiValueInterpretation != null) ? pMultiValueInterpretation : (pMultiValueInterpretation = new MultiValueInterpretationElements());
	}
	
	public ParserRule getMultiValueInterpretationRule() {
		return getMultiValueInterpretationAccess().getRule();
	}

	//// TODO: generalize to i..j (XOR ~> 1..1)
	//enum VariabilityInterpretation:
	//	XOR="Alternatives" | OR="OR-Alternatives" | OPT="Optional" | MAND="Mandatory" | CONCAT="Concat";
	public VariabilityInterpretationElements getVariabilityInterpretationAccess() {
		return (unknownRuleVariabilityInterpretation != null) ? unknownRuleVariabilityInterpretation : (unknownRuleVariabilityInterpretation = new VariabilityInterpretationElements());
	}
	
	public EnumRule getVariabilityInterpretationRule() {
		return getVariabilityInterpretationAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
